<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux for ARM</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././mdbook-admonish.css">
        <link rel="stylesheet" href="././1.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Linux for ARM</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="from-authors.html">От авторов</a></li><li class="chapter-item expanded affix "><a href="benefits.html">Преимущества</a></li><li class="chapter-item expanded affix "><a href="before-start.html">Прежде чем начать</a></li><li class="chapter-item expanded affix "><a href="typography.html">Принятые обозначения</a></li><li class="chapter-item expanded affix "><a href="inaccuracies.html">Опечатки и неточности</a></li><li class="chapter-item expanded affix "><a href="arch.html">Целевая архитектура</a></li><li class="chapter-item expanded affix "><a href="software.html">Информация об используемом ПО</a></li><li class="chapter-item expanded "><a href="prepare/index.html"><strong aria-hidden="true">1.</strong> Подготовка к сборке</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prepare/requrements.html"><strong aria-hidden="true">1.1.</strong> Требования к хосту</a></li><li class="chapter-item expanded "><a href="prepare/about-sbu.html"><strong aria-hidden="true">1.2.</strong> О времени сборки пакетов</a></li><li class="chapter-item expanded "><a href="prepare/add-user.html"><strong aria-hidden="true">1.3.</strong> Создание пользователя lfa</a></li><li class="chapter-item expanded "><a href="prepare/set-env.html"><strong aria-hidden="true">1.4.</strong> Настройка окружения</a></li><li class="chapter-item expanded "><a href="prepare/set-build-env.html"><strong aria-hidden="true">1.5.</strong> Установка переменных сборки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prepare/set-build-env-aarch64.html"><strong aria-hidden="true">1.5.1.</strong> Для архитектуры AArch64</a></li><li class="chapter-item expanded "><a href="prepare/set-build-env-other.html"><strong aria-hidden="true">1.5.2.</strong> Для других архитектур</a></li></ol></li><li class="chapter-item expanded "><a href="prepare/create-dirs.html"><strong aria-hidden="true">1.6.</strong> Создание основных каталогов</a></li><li class="chapter-item expanded "><a href="prepare/download-packages.html"><strong aria-hidden="true">1.7.</strong> Скачивание пакетов</a></li></ol></li><li class="chapter-item expanded "><a href="cross-compiler/index.html"><strong aria-hidden="true">2.</strong> Сборка кросс-компилятора</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cross-compiler/linux-headers.html"><strong aria-hidden="true">2.1.</strong> linux-headers</a></li><li class="chapter-item expanded "><a href="cross-compiler/binutils.html"><strong aria-hidden="true">2.2.</strong> binutils</a></li><li class="chapter-item expanded "><a href="cross-compiler/gcc-p1.html"><strong aria-hidden="true">2.3.</strong> gcc (проход 1)</a></li><li class="chapter-item expanded "><a href="cross-compiler/musl.html"><strong aria-hidden="true">2.4.</strong> musl</a></li><li class="chapter-item expanded "><a href="cross-compiler/gcc-p2.html"><strong aria-hidden="true">2.5.</strong> gcc (проход 2)</a></li><li class="chapter-item expanded "><a href="cross-compiler/check.html"><strong aria-hidden="true">2.6.</strong> Проверка кросс-компилятора</a></li><li class="chapter-item expanded "><a href="cross-compiler/cleanup.html"><strong aria-hidden="true">2.7.</strong> Очистка и сохранение</a></li><li class="chapter-item expanded "><a href="cross-compiler/env.html"><strong aria-hidden="true">2.8.</strong> Объявление дополнительных переменных</a></li></ol></li><li class="chapter-item expanded "><a href="base/index.html"><strong aria-hidden="true">3.</strong> Сборка базовой системы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="base/create-files.html"><strong aria-hidden="true">3.1.</strong> Создание файлов и каталогов</a></li><li class="chapter-item expanded "><a href="base/libgcc.html"><strong aria-hidden="true">3.2.</strong> libgcc</a></li><li class="chapter-item expanded "><a href="base/musl.html"><strong aria-hidden="true">3.3.</strong> musl</a></li><li class="chapter-item expanded "><a href="base/busybox.html"><strong aria-hidden="true">3.4.</strong> busybox</a></li><li class="chapter-item expanded "><a href="base/iana-etc.html"><strong aria-hidden="true">3.5.</strong> iana-etc</a></li><li class="chapter-item expanded "><a href="base/wireless-tools.html"><strong aria-hidden="true">3.6.</strong> wireless-tools</a></li></ol></li><li class="chapter-item expanded "><a href="set-base/index.html"><strong aria-hidden="true">4.</strong> Настройка базовой системы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="set-base/fstab.html"><strong aria-hidden="true">4.1.</strong> Создание /etc/fstab</a></li><li class="chapter-item expanded "><a href="set-base/mdev.html"><strong aria-hidden="true">4.2.</strong> Настройка mdev</a></li><li class="chapter-item expanded "><a href="set-base/profile.html"><strong aria-hidden="true">4.3.</strong> Создание /etc/profile</a></li><li class="chapter-item expanded "><a href="set-base/hostname.html"><strong aria-hidden="true">4.4.</strong> Установка имени хоста</a></li><li class="chapter-item expanded "><a href="set-base/network.html"><strong aria-hidden="true">4.5.</strong> Настройка сети</a></li></ol></li><li class="chapter-item expanded "><a href="kernel/index.html"><strong aria-hidden="true">5.</strong> Сборка ядра</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/linux.html"><strong aria-hidden="true">5.1.</strong> linux</a></li></ol></li><li class="chapter-item expanded "><a href="bootloader/index.html"><strong aria-hidden="true">6.</strong> Сборка загрузчика</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bootloader/allwinner.html"><strong aria-hidden="true">6.1.</strong> Allwinner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bootloader/allwinner-tf-a.html"><strong aria-hidden="true">6.1.1.</strong> Сборка TF-A</a></li><li class="chapter-item expanded "><a href="bootloader/allwinner-or2k-cc.html"><strong aria-hidden="true">6.1.2.</strong> Установка кросс-компилятора or2k</a></li><li class="chapter-item expanded "><a href="bootloader/allwinner-crust.html"><strong aria-hidden="true">6.1.3.</strong> Сборка SCP (crust)</a></li><li class="chapter-item expanded "><a href="bootloader/allwinner-uboot.html"><strong aria-hidden="true">6.1.4.</strong> Сборка U-Boot</a></li></ol></li><li class="chapter-item expanded "><a href="bootloader/broadcom.html"><strong aria-hidden="true">6.2.</strong> Broadcom</a></li><li class="chapter-item expanded "><a href="bootloader/rockchip.html"><strong aria-hidden="true">6.3.</strong> Rockchip</a></li><li class="chapter-item expanded "><a href="bootloader/qemu.html"><strong aria-hidden="true">6.4.</strong> Эмуляция в QEMU (ARM)</a></li></ol></li><li class="chapter-item expanded "><a href="boot-files/index.html"><strong aria-hidden="true">7.</strong> Создание прочих загрузочных файлов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="boot-files/bootscripts.html"><strong aria-hidden="true">7.1.</strong> Загрузочные скрипты</a></li><li class="chapter-item expanded "><a href="boot-files/uInitrd.html"><strong aria-hidden="true">7.2.</strong> Создание uInitrd</a></li><li class="chapter-item expanded "><a href="boot-files/boot.scr.html"><strong aria-hidden="true">7.3.</strong> Создание boot.scr</a></li></ol></li><li class="chapter-item expanded "><a href="create-img.html"><strong aria-hidden="true">8.</strong> Сборка образа</a></li><li class="chapter-item expanded "><a href="next.html"><strong aria-hidden="true">9.</strong> Что далее?</a></li><li class="chapter-item expanded "><a href="additional/index.html"><strong aria-hidden="true">10.</strong> Вспомогательные материалы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="additional/arm.html"><strong aria-hidden="true">10.1.</strong> Процессоры ARM</a></li><li class="chapter-item expanded "><a href="additional/os-structure.html"><strong aria-hidden="true">10.2.</strong> Заметки об ОС Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="additional/os-structure1.html"><strong aria-hidden="true">10.2.1.</strong> Часть 1</a></li><li class="chapter-item expanded "><a href="additional/os-structure2.html"><strong aria-hidden="true">10.2.2.</strong> Часть 2</a></li><li class="chapter-item expanded "><a href="additional/os-structure3.html"><strong aria-hidden="true">10.2.3.</strong> Часть 3</a></li><li class="chapter-item expanded "><a href="additional/os-structure4.html"><strong aria-hidden="true">10.2.4.</strong> Часть 4</a></li></ol></li><li class="chapter-item expanded "><a href="additional/pkgmgt.html"><strong aria-hidden="true">10.3.</strong> Управление пакетами</a></li><li class="chapter-item expanded "><a href="additional/compile.html"><strong aria-hidden="true">10.4.</strong> Сборка ПО из исходного кода</a></li><li class="chapter-item expanded "><a href="additional/cross-compiler.html"><strong aria-hidden="true">10.5.</strong> Кросс-компилятор</a></li><li class="chapter-item expanded "><a href="additional/fpu.html"><strong aria-hidden="true">10.6.</strong> FPU в ARM-процессорах</a></li><li class="chapter-item expanded "><a href="additional/dtb.html"><strong aria-hidden="true">10.7.</strong> Device Tree</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">11.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/computers.html"><strong aria-hidden="true">11.1.</strong> Список ПК, на которых собиралась LFA</a></li></ol></li><li class="chapter-item expanded "><a href="literature.html"><strong aria-hidden="true">12.</strong> Литература</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="whatsnew.html"><strong aria-hidden="true">13.</strong> Что нового в этом релизе</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">14.</strong> Список изменений</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux for ARM</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linux-for-arm/handbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-for-arm"><a class="header" href="#linux-for-arm">Linux for ARM</a></h1>
<blockquote>
<ul>
<li><strong>Автор(ы):</strong> <a href="https://github.com/mskrasnov">Pelmen Zharenny</a></li>
<li><strong>Связаться с автором:</strong> <a href="https://t.me/brezhnev_zhiv">Telegram</a></li>
<li><strong>Версия LFA:</strong> 1.0 Alpha 1</li>
</ul>
</blockquote>
<p>Linux for ARM (далее — <em>LFA</em>) — подробное руководство по сборке Linux-системы из исходного кода для компьютеров на архитектуре ARM<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>На данный момент в руководстве описаны сведения о сборке Linux ОС для SoC Allwinner, Broadcom и Rockchip.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Предисловие"><a class="header" href="#Предисловие">Предисловие</a></h1>
<p>В декабре 2023 года я приобрёл себе одноплатник Orange Pi 3 LTS. Скачанная с офсайта Orange Pi система Debian оказалась настолько кривой, что я через какоето время удалил её, установив дистрибутив Armbian. У последнего был ряд преимуществ в виде первичной настройки системы (после первой загрузки запускалась консольная утилита, в которой человек создавал пользователя, от имени которого будет работать, настраивал время и локализацию и совершал ещё ряд каких-то действий). Но были и недостатки: у меня просто не сохранялся ряд настроек системы (да и браузер Firefox тоже вёл себя очень странно), да и сама система была собрана не очень корректно. Пробовал ставить Manjaro Linux, но и с ней были проблемы, а именно видеоартефакты.</p>
<p>Да и в тех дистрибутивах, что я использовал на моей Orange Pi, было огромное число абсолютно не нужного и лишнего ПО, которое только засоряло систему и занимало драгоценное место на SD-карте.</p>
<p>Поэтому я решился на сборку своей системы Linux из исходного кода. До этого я увлекался LFS, поэтому у меня был небольшой опыт сборки таких систем, но не было опыта <em>кросс-компиляции</em> системы для другой архитектуры.</p>
<p>LFA, на мой взгляд, является неплохим pet-проектом, которым я занимаюсь исключительно в свободное время. Будет что показать будущим работодателям :).</p>
<h2 id="Почему-создан-очередной-lfs-неужели-нет-готовых-решений"><a class="header" href="#Почему-создан-очередной-lfs-неужели-нет-готовых-решений">Почему создан «очередной LFS», неужели нет готовых решений?</a></h2>
<p>Основная причина создания LFA: необходимость зафиксировать для себя любимого те действия, которые я выполнял для сборки своей Linux-системы чтобы потом к ним в будущем вернуться и либо исправить, чтобы они стали корректными или более предпочтительными, либо чтобы вернуться к ним в будущем. Следовательно, LFA сама по себе предназначена только для меня (автора руководства), однако я надеюсь, что информация отсюда откажется полезна и другим людям.</p>
<p>Создание руководства по сбокре своего дистрибутива Linux для ARM-компьютеров в чём-то ново, поскольку достаточно известные руководства типа <a href="https://www.linuxfromscratch.org">LFS</a> или <a href="https://lx4u.ru">Linux для себя</a> предназначены для x86/x86_64 компьютеров, а для ARM-девайсов особой информации не так уж и много, а руководство <a href="https://clfs.org/view/clfs-embedded/arm">CLFS Embedded</a>, на основе которого и создана LFA, давно заброшено и, как следствие, несколько устарело.</p>
<h2 id="Что-lfa-предоставляет-пользователю"><a class="header" href="#Что-lfa-предоставляет-пользователю">Что LFA предоставляет пользователю?</a></h2>
<p>В данном руководстве вы не увидите информации о сборке пригодной к <em>использованию</em> системы, в которой будет браузер, офисный пакет, рабочее окружение и куча игр. Здесь не будет сведений о сборке системы, пригодной к использованию в IoT или умном доме. Предполагается, что вы дойдёте до этого сами.</p>
<p>LFA предназначена в первую очередь для того, чтобы показать вам, как потенциальному разработчику для Linux, отличия ARM-компьютеров от их x86_64 &quot;собратьев&quot;. LFA, может быть, даст вам опыт в сборке программного обеспечения, а также, наверное, расскажет вам о строении Linux-систем. Но это не точно. Основная идея LFA заключается в том, что только вы решаете, собирать ли систему для ARM-ПК, а если и собирать, то <em>что</em> и <em>каким образом</em>. LFA предоставляет лишь шаблон, по которому можно это сделать.</p>
<h2 id="Отличия-от-clfs"><a class="header" href="#Отличия-от-clfs">Отличия от CLFS</a></h2>
<p>Важным отличием от CLFS является то, что LFA полностью на русском языке. К тому же, LFA ориентирована на аудиторию, проживающую в странах СНГ, т.е. тех людей, которые хотя бы на базовом уровне владеют русским языком.</p>
<p>В LFA приводятся различные дополнительные сведения, касающиеся как в целом ОС, использующих ядро Linux, так и таковых систем, предназначенных для компьютеров с архитектурой ARM. В данном руководстве приведены рекомендуемые параметры сборки для некоторых конкретных моделей ПК.</p>
<p>Здесь используются относительно новые версии программного обеспечения, в то время как последний релиз CLFS Embedded для ARM был датирован 2019 годом. В новых версиях ПО исправляют ошибки и уязвимости, а также добавляют новый функционал.</p>
<p>В конце некоторых страниц может быть расположен блок «Смотрите также» со ссылками на дополнительные сведения, документацию или внешние ресурсы. Если вы хотите знать больше, можете ознакомиться с информацией по ссылкам из этого блока.</p>
<p>И в завершение, LFA предоставляет инструкции по сборке загрузчика U-Boot (на данный момент для плат на основе SoC Allwinner, Broadcom, Rockchip и для эмуляции в QEMU).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="От-авторов"><a class="header" href="#От-авторов">От авторов</a></h1>
<p>Мы, разработчики LFA, ценим, что вы читаете это руководство. Надеемся, что оно принесёт вам как образовательную пользу, так и, возможно, практическую.</p>
<p>Если у вас возникли вопросы или проблемы, либо вы хотите внести свой вклад в развитие данного руководства, то, пожалуйста, оставьте запрос в нашем репозитории по адресу <a href="https://github.com/Linux-for-ARM/handbook/issues/new">https://github.com/Linux-for-ARM/handbook</a>.</p>
<p><em>С уважением, команда Linux for ARM.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Преимущества"><a class="header" href="#Преимущества">Преимущества</a></h1>
<p>Главная цель этого руководства — дать вам, как потенциальному разработчику дистрибутивов Linux для ARM-компьютеров, понимание того, как работают операционные системы, использующие ядро Linux, на компьютерах с ARM-процессорами. Сборка своей системы с нуля для ARM-компьютеров поможет узнать, как всё работает вместе и как каждый компонент системы взаимодействует с другим. Возможно, что собранная вашими руками система будет намного надёжнее и удобнее уже существующих «портов» дистрибутивов GNU/Linux на ARM. Кроме того, LFA даст опыт в сборке ПО из исходного кода, что может пригодиться и при администрировании «обычных» ОС GNU/Linux, предназначенных для работы на x86(_64) компьютерах.</p>
<p>Как я обнаружил, сборка системы из исходного кода - это довольно сложная работа, но в то же время интересная и в чём-то весёлая, и вы действительно чему-либо научитесь, поскольку вам нужно настроить каждый отдельный аспект системы. Это заставляет вас читать множество руководств по настройке различных компонентов ОС. Кроме того, это даёт вам контроль над системой: вы точно знаете, какое ПО установлено, как оно настроено и где хранятся его файлы.</p>
<p>Другое ключевое преимущество — независимость от других сборщиков. Только вы решаете, что собирать, а что нет, какие применять патчи и как настраивать систему.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Прежде-чем-начать"><a class="header" href="#Прежде-чем-начать">Прежде чем начать</a></h1>
<p>Сборка своей системы — не самая простая задача. От вас потребуются знания в администрировании UNIX-систем для того, чтобы вы имели возможность устранять проблемы в процессе сборки, правильно выполнять ввод требуемых команд и при необходимости изменять ход сборки программного обеспечения в зависимости от ваших потребностей и желаний.</p>
<p>Во-первых, вы должны уметь пользоваться терминалом, в частности, владеть программами из состава <code>coreutils</code><sup class="footnote-reference"><a href="#1">1</a></sup>, копировать и перемещать файлы и каталоги, просматривать содержимое директорий и файлов. Также ожидается, что у вас есть знания о процессе установки программного обеспечения в Linux.</p>
<p>Рекомендуем чаще обращаться к разделу <a href="additional/index.html">«Вспомогательные материалы»</a>, в котором находятся ответы на часто задаваемые вопросы. В этот раздел часто добавляются новые сведения.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Программы для работы с файлами (копирование, удаление, перемещение, создание), правами доступа, вычисления контрольных сумм и т.д.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Принятые-обозначения"><a class="header" href="#Принятые-обозначения">Принятые обозначения</a></h1>
<p>В руководстве используются следующие обозначения:</p>
<pre><code class="language-bash">./configure --prefix=/usr --target=$LFA_TGT
</code></pre>
<p>Этот текст необходимо набрать в терминале в точности так, как указано, если иное не сказано в тексте.</p>
<p>Иногда строка разделяется до двух или более с использованием символа <code>\</code>:</p>
<pre><code class="language-bash">ARCH=arm ./configure --prefix=/usr \
    --target=$LFA_TGT \
    --with-sysroot=$LFA_SYS \
    --disable-nls \
    --disable-threads
</code></pre>
<p><em>Обратите внимание на то, что после <code>\</code> должен быть переход на новую строку (<kbd>Enter</kbd>). Другие символы приведут к некорректному результату и ошибкам.</em></p>
<pre><code>2024-02-27 18:58:13 [INFO] (mdbook::cmd::serve): Files changed: [&quot;/home/admin/Work/lfa/src/typography.md&quot;]
2024-02-27 18:58:13 [INFO] (mdbook::cmd::serve): Building book...
2024-02-27 18:58:13 [INFO] (mdbook::book): Book building has started
2024-02-27 18:58:13 [INFO] (mdbook::book): Running the html backend
</code></pre>
<p>Этот текст используется для отображения вывода в терминале.</p>
<p><em>Используется, чтобы подчеркнуть важную информацию, на которую следует обратить внимание.</em></p>
<p><a href="typography.html">Используется для ссылок на страницы руководства.</a></p>
<p><a href="https://linux-for-arm.github.io/donate.html"><strong>Используется для ссылок на внешние ресурсы</strong></a> (только в главах 2-7 и в главе 10).</p>
<div id="admonition-Важно" class="admonition admonish-warning">
<div class="admonition-title">
<p>Важно</p>
<p><a class="admonition-anchor-link" href="typography.html#admonition-Важно"></a></p>
</div>
<div>
<p>Используется для указания на критически важную информацию. На неё следует обратить особое внимание.</p>
</div>
</div>
<blockquote>
<p>Используется для указания на информацию рекомендательного характера. Не рекомендуется пропускать эти указания и внимательно с ними ознакомиться.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Опечатки-и-неточности"><a class="header" href="#Опечатки-и-неточности">Опечатки и неточности</a></h1>
<p>Если вы нашли в руководстве ошибку, опечатку или хотите предложить нам какое-либо изменение, которое, на ваш взгляд, важно для LFA, то, пожалуйста, оставьте запрос в нашем <a href="https://github.com/Linux-for-ARM/handbook/issues/new">репозитории</a> на GitHub. Мы открыты к диалогу, и вы, как читатель, всегда можете предложить свои замечания, улучшения и изменения.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Целевая-архитектура"><a class="header" href="#Целевая-архитектура">Целевая архитектура</a></h1>
<p>Предполагается, что LFA будет собираться для архитектуры ARMv8 (AArch64). Работа собранной по LFA системы проверялась на процессоре<sup class="footnote-reference"><a href="#1">1</a></sup> Allwinner H6 (ARM Cortex-A53<sup class="footnote-reference"><a href="#2">2</a></sup>). С другой стороны, в данном руководстве ещё <a href="prepare/set-build-env.html">остались</a> инструкции, содержащий в том числе сведения для более старых архитектур семейства ARM в наследие от руководства CLFS Embedded. В ближайшее время мы не планируем удалять их или как-то актуализировать, по крайней мере это не будет сделано до релиза 2.0. Тем не менее, основной архитектурой для нас является ARMv8.</p>
<p>Для сборки LFA для того или иного AArch64-процессора мы будем использовать x86_64 хост. Компиляция ПО будет производиться посредством <a href="additional/cross-compiler.html">кросс-компилятора</a>, который мы соберём в начале и будем использовать на протяжении всего руководства.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>В адрес подобных устройств куда справедливее использовать термин «SoC» (System on Chip, Система на Кристалле), но для простоты ограничимся понятием «процессор».</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Существуют процессоры Cortex-A, предназначенные для устройств, требующих относительно высокой производительности, Cortex-R для ПО, работающего в режиме реального времени и Cortex-M для микроконтроллеров и встраиваемых устройств. В данном руководстве идёт упор на процессоры Cortex-A.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Информация-об-используемом-ПО"><a class="header" href="#Информация-об-используемом-ПО">Информация об используемом ПО</a></h1>
<p>Как говорилось ранее, в LFA содержатся инструкции только по сборке базового программного обеспечения. Собранная система будет включать в себя базовое программное обеспечение для работы с файлами, процессами и сетью. Однако это не значит, что полученная система будет максимально компактной.</p>
<h2 id="busybox-1361"><a class="header" href="#busybox-1361">BusyBox-1.36.1</a></h2>
<p>Объединяет крошечные версии многих распространённых утилит UNIX в один небольшой двоичный файл (1-2 Мбайт). Он заменяет большинство утилит, которые обычно находятся в GNU Coreutils, GNU Findutils и т.д.</p>
<ul>
<li>Домашняя страница: <a href="https://www.busybox.net">https://www.busybox.net</a></li>
<li>Скачать: <a href="https://busybox.net/downloads/busybox-1.36.1.tar.bz2">https://busybox.net/downloads/busybox-1.36.1.tar.bz2</a></li>
<li>MD5 сумма: <code>0fc591bc9f4e365dfd9ade0014f32561</code></li>
</ul>
<h2 id="gcc-1320"><a class="header" href="#gcc-1320">GCC-13.2.0</a></h2>
<p>Набор компиляторов GNU GCC.</p>
<ul>
<li>Домашняя страница: <a href="https://gcc.gnu.org">https://gcc.gnu.org</a></li>
<li>Скачать: <a href="https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.xz">https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.xz</a></li>
<li>MD5 сумма: <code>e0e48554cc6e4f261d55ddee9ab69075</code></li>
</ul>
<h2 id="gmp-630"><a class="header" href="#gmp-630">GMP-6.3.0</a></h2>
<p>Пакет с математическими библиотеками, которые предоставляют полезные функции для арифметики произвольной точности. Необходим для сборки GCC.</p>
<ul>
<li>Домашняя страница: <a href="https://gmplib.org">https://gmplib.org</a></li>
<li>Скачать: <a href="https://ftp.gnu.org/gnu/gmp/gmp-6.3.0.tar.xz">https://ftp.gnu.org/gnu/gmp/gmp-6.3.0.tar.xz</a></li>
<li>MD5 сумма: <code>956dc04e864001a9c22429f761f2c283</code></li>
</ul>
<h2 id="linux-666"><a class="header" href="#linux-666">Linux-6.6.6</a></h2>
<p>Ядро операционной системы.</p>
<ul>
<li>Домашняя страница: <a href="https://www.kernel.org">https://www.kernel.org</a></li>
<li>Скачать: <a href="https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.6.6.tar.xz">https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.6.6.tar.xz</a></li>
<li>MD5 сумма: <code>dd66281fed9b76c08dc8b72eb76df96f</code></li>
</ul>
<h2 id="mpc-131"><a class="header" href="#mpc-131">MPC-1.3.1</a></h2>
<p>Математические функции для комплексных чисел. Необходим для сборки GCC.</p>
<ul>
<li>Домашняя страница: <a href="http://www.multiprecision.org/">http://www.multiprecision.org/</a></li>
<li>Скачать: <a href="https://ftp.gnu.org/gnu/mpc/mpc-1.3.1.tar.gz">https://ftp.gnu.org/gnu/mpc/mpc-1.3.1.tar.gz</a></li>
<li>MD5 сумма: <code>5c9bc658c9fd0f940e8e3e0f09530c62</code></li>
</ul>
<h2 id="mpfr-421"><a class="header" href="#mpfr-421">MPFR-4.2.1</a></h2>
<p>Функции для арифметики множественной точности. Необходим для сборки GCC.</p>
<ul>
<li>Домашняя страница: <a href="https://www.mpfr.org">https://www.mpfr.org</a></li>
<li>Скачать: <a href="https://ftp.gnu.org/gnu/mpfr/mpfr-4.2.1.tar.xz">https://ftp.gnu.org/gnu/mpfr/mpfr-4.2.1.tar.xz</a></li>
<li>MD5 сумма: <code>523c50c6318dde6f9dc523bc0244690a</code></li>
</ul>
<h2 id="tf-a-2102"><a class="header" href="#tf-a-2102">TF-A-2.10.2</a></h2>
<p>Проект Trusted Firmware-A предоставляет эталонную реализацию безопасного программного обеспечения для процессоров класса ARMv7-A и ARMv8-A.</p>
<ul>
<li>Домашняя страница: <a href="https://www.trustedfirmware.org/projects/tf-a/">https://www.trustedfirmware.org/projects/tf-a/</a></li>
<li>Скачать: <a href="https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/snapshot/trusted-firmware-a-lts-v2.10.2.tar.gz">https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/snapshot/trusted-firmware-a-lts-v2.10.2.tar.gz</a></li>
<li>MD5 сумма: <code>9d223fd5e7863ec223565c385f9a68ed</code></li>
</ul>
<h2 id="wireless-tools-29"><a class="header" href="#wireless-tools-29">Wireless Tools-29</a></h2>
<p>Набор инструментов для работы с Wireless Extensions (WE — API ядра Linux, позволяющий драйверу передавать в пользовательское пространство конфигурацию и статистику, характерные для беспроводных локальных сетей).</p>
<ul>
<li>Домашняя страница: <a href="https://hewlettpackard.github.io/wireless-tools/">https://hewlettpackard.github.io/wireless-tools/</a></li>
<li>Скачать: <a href="https://hewlettpackard.github.io/wireless-tools/wireless_tools.29.tar.gz">https://hewlettpackard.github.io/wireless-tools/wireless_tools.29.tar.gz</a></li>
<li>MD5 сумма: <code>e06c222e186f7cc013fd272d023710cb</code></li>
</ul>
<h2 id="binutils-242"><a class="header" href="#binutils-242">binutils-2.42</a></h2>
<p>Этот пакет содержит компоновщик, ассемблер и другие утилиты для работы с объектными файлами.</p>
<ul>
<li>Домашняя страница: <a href="https://www.gnu.org/software/binutils">https://www.gnu.org/software/binutils</a></li>
<li>Скачать: <a href="https://sourceware.org/pub/binutils/releases/binutils-2.42.tar.xz">https://sourceware.org/pub/binutils/releases/binutils-2.42.tar.xz</a></li>
<li>MD5 сумма: <code>a075178a9646551379bfb64040487715</code></li>
</ul>
<h2 id="iana-etc-20240125"><a class="header" href="#iana-etc-20240125">iana-etc-20240125</a></h2>
<p>Данные для сетевых служб и сервисов. Необходим для обеспечения надлежащих сетевых возможностей.</p>
<ul>
<li>Домашняя страница: <a href="https://www.iana.org/protocols">https://www.iana.org/protocols</a></li>
<li>Скачать: <a href="https://github.com/Mic92/iana-etc/releases/download/20240125/iana-etc-20240125.tar.gz">https://github.com/Mic92/iana-etc/releases/download/20240125/iana-etc-20240125.tar.gz</a></li>
<li>MD5 сумма: <code>aed66d04de615d76c70890233081e584</code></li>
</ul>
<h2 id="musl-125"><a class="header" href="#musl-125">musl-1.2.5</a></h2>
<p>Минималистичная стандартная библиотека языка С.</p>
<ul>
<li>Домашняя страница: <a href="https://musl.libc.org">https://musl.libc.org</a></li>
<li>Скачать: <a href="https://musl.libc.org/releases/musl-1.2.5.tar.gz">https://musl.libc.org/releases/musl-1.2.5.tar.gz</a></li>
<li>MD5 сумма: <code>ac5cfde7718d0547e224247ccfe59f18</code></li>
</ul>
<h2 id="u-boot-202310"><a class="header" href="#u-boot-202310">u-boot-2023.10</a></h2>
<p>Загрузчик операционной системы, предназначенный для встраиваемых систем на MIPS, ARM, PowerPC и т.д.</p>
<ul>
<li>Домашняя страница: <a href="https://source.denx.de/u-boot/u-boot">https://source.denx.de/u-boot/u-boot</a></li>
<li>Скачать: <a href="https://source.denx.de/u-boot/u-boot/-/archive/v2023.10/u-boot-v2023.10.tar.bz2">https://source.denx.de/u-boot/u-boot/-/archive/v2023.10/u-boot-v2023.10.tar.bz2</a></li>
<li>MD5 сумма: <code>3491cd4aa6c52a7c77f7f626d4df9442</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Подготовка-к-сборке"><a class="header" href="#Подготовка-к-сборке">Подготовка к сборке</a></h1>
<p>В данной главе приведены сведения, касаемые подготовки вашей хост-системы к сборке LFA. Вам требуется создать пользователя, настроить его окружение и создать базовую структуру каталогов собираемой системы.</p>
<h2 id="Ход-сборки-lfa"><a class="header" href="#Ход-сборки-lfa">Ход сборки LFA</a></h2>
<ol>
<li><strong>Подготовка к сборке</strong> - на данном этапе мы создадим отдельного пользователя, от имени которого будем собирать систему, настроим его окружение и подготовим всё, что требуется для сборки LFA.</li>
<li><strong>Сборка кросс-компилятора</strong> - поскольку сборка производится с компьютера x86_64 для компьютера AArch64, нам требуется собрать кросс-компилятор, позволяющий выполнить это. После сборки с его помощью базовой системы мы его удалим.</li>
<li><strong>Сборка базовой системы</strong> - здесь мы собирём базовую систему, которая и будет являться той самой LFA.</li>
<li><strong>Настройка базовой системы</strong> - на данном этапе требуется произвести настройку базовой системы: создать ряд конфигурационных файлов и при необходимости исправить существующие.</li>
<li><strong>Сборка ядра</strong> - на данном этапе необходимо собрать ядро Linux с учётом всех ваших требований и пожеланий.</li>
<li><strong>Сборка загрузчика</strong> - заключительный этап, на котором вы соберёте загрузчик U-Boot для конкретной модели компьютера, для которой вы собираете систему LFA.</li>
<li><strong>Конец</strong> - сборка системы полностью завершилась. Теперь остаётся сделать img-образ, пригодный для записи на внешний носитель, который будет выступать в роли загрузочного в компьютере, для которого вы собирали LFA.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Требования-к-хосту"><a class="header" href="#Требования-к-хосту">Требования к хосту</a></h1>
<h2 id="Оборудование"><a class="header" href="#Оборудование">Оборудование</a></h2>
<ul>
<li>Раздел на жёстком диске или просто свободное место, рекомендуемый объём которого - 10 Гб и более.</li>
<li>Если оперативной памяти хост-компьютера мало (менее 4 Гб), рекомендуется создать раздел или файл подкачки. Кроме того, можно использовать <code>zram</code>.</li>
</ul>
<h2 id="Программное-обеспечение"><a class="header" href="#Программное-обеспечение">Программное обеспечение</a></h2>
<p>На вашей хост-системе должно быть установлено ПО из списка ниже с указанными минимальными версиями. Для большинства современных дистрибутивов Linux это не должно быть особой проблемой.</p>
<ul>
<li><code>bash-3.2</code> (<code>/bin/sh</code> должна быть ссылкой на <code>bash</code>)</li>
<li><code>bc-1.07</code> (для компиляции Linux)</li>
<li><code>binutils-2.13</code></li>
<li><code>bison-2.7</code> (<code>/usr/bin/yacc</code> должен быть ссылкой на <code>bison</code>)</li>
<li><code>coreutils-8.1</code></li>
<li><code>diffutils-2.8.1</code></li>
<li><code>findutils-4.2.31</code></li>
<li><code>gawk-4.0.1</code> (<code>/usr/bin/awk</code> должен быть ссылкой на <code>gawk</code>)</li>
<li><code>gcc-5.2</code> (влючающий компилятор языка С)</li>
<li><code>grep-2.5.1a</code></li>
<li><code>gzip-1.3.12</code></li>
<li><code>linux-4.19</code></li>
<li><code>m4-1.4.10</code></li>
<li><code>make-4.0</code></li>
<li><code>patch-2.5.4</code></li>
<li><code>perl-5.8.8</code></li>
<li><code>python-3.4</code></li>
<li><code>rsync-3.2.7</code> (для установки заголовков ядра на этапе сборки кросс-компилятора)</li>
<li><code>sed-4.1.5</code></li>
<li><code>setuptools-66.1</code> (для компиляции U-Boot)<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li><code>swig-4.0</code> (для компиляции U-Boot)</li>
<li><code>tar-1.22</code></li>
<li><code>u-boot-tools-2023.01</code> (для сборки ядра Linux и работы с загрузчиком U-Boot)</li>
<li><code>xz-5.0</code></li>
<li><code>wget-1.23</code> и <code>md5sum</code> (для скачивания исходного кода LFA)</li>
</ul>
<p>Если вы собираетесь сделать систему для компьютера на базе Allwinner SoC (например, этот SoC используется в ряде моделей Orange Pi, например в Orange Pi 3 LTS), то для сборки одного из компонентов загрузчика U-Boot вам будет нужен кросс-компилятор для архитектуры <code>or1k</code>. В этом руководстве не приводится сведений о его сборке (сборка сначала кросс-компилятора для ARM, потом кросс-компилятора для OpenRISC усложнит и раздует LFA и собьёт с толку тех читателей, кто не пользуется Allwinner), однако вы можете либо использовать готовый кросс-компилятор для этой архитектуры (например, некоторые дистрибутивы, такие как ArchLinux, содержат в репозиториях пакеты с Binutils и GCC для данной архитектуры), либо собрать его самостоятельно В скором времени проектом LFA будут подготовлены как инструкции по сборке такого кросс-компилятора (они не будут входить в состав основного руководства, а будут доступны отдельно) и готовая версия такого кросс-компилятора.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Это модуль языка Python, который может быть установлен с помощью пакетного менеджера <code>pip</code> (входит в состав Python и обычно устанавливается вместе с ним), либо с помощью пакетного менеджера вашего дистрибутива, если в его репозиториях поставляются пакеты для Python (в таком случае имя пакета, содержащего Python-модуль <code>setuptools</code>, может быть <code>python-setuptools</code> или <code>python3-setuptools</code>). Использование пакетного менеджера вашего дистрибутива вместо <code>pip</code> предпочтительнее, поскольку в таком случае <code>setuptools</code> будут установлены именно в систему, откуда интерпретатор Python будет иметь к нему доступ. С недавнего времени пакетный менеджер <code>pip</code> отключил «глобальную» установку Python-модулей в систему по умолчанию, став предпочитать установку модулей в виртуальное окружение Python.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="О-времени-сборки-пакетов"><a class="header" href="#О-времени-сборки-пакетов">О времени сборки пакетов</a></h1>
<p>Время сборки пакетов во многом зависит от мощности компьютера. Но также на время влияют и иные факторы, такие как, например, версия компилятора и системы сборки, а также использование многопоточной сборки.</p>
<p>Поскольку от компьютера к компьютеру время сборки может меняться (на одном ПК пакет <code>some-pkg</code> собирается за 3 минуты, а на другом тот же <code>some-pkg</code> — за 3 недели), в руководстве введена специальная единица времени, которая называется «ОВС» (Относительное Время Сборки).</p>
<p>1 ОВС равна времени сборки первого пакета. К примеру, если первый пакет в этом руководстве собирается за 3 минуты, то 1 ОВС = 3 мин. Если время сборки какого-то пакета = 10 ОВС, то, переводя в минуты, это будет 30 минут.</p>
<blockquote>
<p>ОВС не даёт совсем точных значений, поскольку они зависят от многих факторов, включая версию компилятора GCC на хост-системе. ОВС нужна для <em>примерной</em> оценки времени сборки пакета.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-пользователя-lfa"><a class="header" href="#Создание-пользователя-lfa">Создание пользователя lfa</a></h1>
<p>Рекомендуем выполнять сборку от имени отдельного пользователя, у которого будет доступ только к ограниченному набору файлов. Не рекомендуем вам собирать систему от имени текущего пользователя или пользователя <code>root</code>, так как, если вы ошиблись в наборе команд для сборки, есть вероятность порчи или потери пользовательских данных или поломки системы.</p>
<p>Вы можете использовать произвольного пользователя, но для упрощения настройки чистого рабочего окружения создайте нового пользователя с именем <code>lfa</code> как члена группы <code>lfa</code>:</p>
<details id="admonition-Внимание" class="admonition admonish-warning">
<summary class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="prepare/add-user.html#admonition-Внимание"></a></p>
</summary>
<div>
<p>Если вы читаете PDF-версию руководства и хотите <em>скопировать</em> из него команды далее в терминал, рекомендуем вам не делать этого. Несмотря на то, что сами команды корректные (и правильно отображаются в PDF-книге), при копировании зачастую в буфер обмена попадают некорректные данные (такой проблемы нет, если вы читаете обычную HTML-версию LFA). Рекомендуем <em>перепечатывать</em> команды из PDF-версии LFA.</p>
</div>
</details>
<pre><code class="language-bash">groupadd lfa
useradd -s /bin/bash -g lfa -m -k /dev/null lfa
</code></pre>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>groupadd lfa</code> - создаёт новую группу <code>lfa</code>.</p>
<p><code>-s /bin/bash</code> - указывает <code>/bin/bash</code> оболочкой по умолчанию для пользователя <code>lfa</code>.</p>
<p><code>-g lfa</code> - добавляет пользователя <code>lfa</code> в группу <code>lfa</code>.</p>
<p><code>-m</code> - создаёт домашнюю директорию пользователя <code>lfa</code> (по умолчанию в <code>/home/lfa</code>).</p>
<p><code>-k /dev/null</code> - предотвращает копирование файлов из <code>/etc/skel</code> - каталога, в котором содержатся стандартные конфиги и иные файлы, которые обычно копируются в домашнюю директорию пользователя во время его создания.</p>
</blockquote>
<p>Когда вы находитесь в терминале от имени пользователя <code>root</code> и переключаетесь на пользователя <code>lfa</code>, вам не требуется ввода пароля <code>lfa</code>. Однако когда вы переключаетесь на <code>lfa</code> с обычного пользователя, без пароля у вас не получится этого сделать.</p>
<p>Задайте для пользователя <code>lfa</code> новый пароль:</p>
<pre><code class="language-bash">passwd lfa
</code></pre>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="prepare/add-user.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Теперь вам необходимо войти от имени <code>lfa</code>. Для этого выполните:</p>
<pre><code class="language-bash">su - lfa
</code></pre>
<p>Если вы прервали сборку LFA досрочно и хотите продолжить её спустя какое-то время, то вам нужно будет выполнить вход в этого пользователя снова с помощью этой же команды.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Настройка-окружения"><a class="header" href="#Настройка-окружения">Настройка окружения</a></h1>
<p>После того, как вы создали нового пользователя, от имени которого будете собирать LFA, нужно настроить его окружение. Как минимум, требуется объявить ряд переменных окружения, которые мы будем использовать при сборке программ. В таких переменных содержатся сведения, неизменные от пакета к пакету. Например, путь, куда нужно устанавливать программы, целевая архитектураи т.п. Если после создания пользователя вы вошли в терминале от его имени, то приступайте к выполнению инструкций ниже. В противном случае от вас требуется сначала войти от имени <code>lfa</code> с помощью команды <code>su - lfa</code>.</p>
<p>Первым делом требуется создать файл <code>~/.bash_profile</code>:</p>
<pre><code class="language-bash">cat &gt; ~/.bash_profile &lt;&lt; &quot;EOF&quot;
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
</code></pre>
<p>При входе в систему от имени пользователя <code>lfa</code> начальной оболочкой обычно является оболочка входа в систему, которая читает файл <code>/etc/profile</code>, содержащий основные общесистемные настройки и переменные окружения, а затем <code>~/.bash_profile</code>. Команда <code>exec env -i ... /bin/bash</code> в последнем заменяет запущенную оболочку новой с абсолютно пустым окружением, за исключением переменных <code>$HOME</code>, <code>$TERM</code> и <code>$PS1</code>. Это гарантирует нам, что никакие нежелательные и потенциально опасные переменные окружения из хост-системы не «просочатся» в нашу среду сборки.</p>
<p>Новый экземпляр оболочки вместо <code>/etc/profile</code> и <code>~/.bash_profile</code> будет читать уже файл <code>~/.bashrc</code>. Создайте его:</p>
<pre><code class="language-bash">cat &gt; ~/.bashrc &lt;&lt; &quot;EOF&quot;
set +h
umask 022
unset CFLAGS
LFA=$HOME/lfa
LC_ALL=C
PATH=$LFA/tools/bin:/bin:/usr/bin
export LFA LC_ALL PATH
EOF
</code></pre>
<h2 id="Применение-изменений"><a class="header" href="#Применение-изменений">Применение изменений</a></h2>
<p>Для того, чтобы применить внесённые нами изменения, выполните:</p>
<pre><code class="language-bash">source ~/.bash_profile
</code></pre>
<blockquote>
<p><strong>Значения параметров <code>~/.bashrc</code>:</strong></p>
<p>Команда <code>set +h</code> отключает хеш-функцию BASH. Хеширование в общем случае является полезной вещью, поскольку BASH использует хеш-таблицу для запоминания полного пути к исполняемым файлам, чтобы не искать путь до исполняемого файла в <code>$PATH</code> снова и снова. Однако новые программы для сборки, которые мы только что установили в <code>$LFA/tools/bin</code>, требуется использовать сразу же после их установки. После отключения хеширования оболочка BASH сразу найдёт только что установленные программы, не вспоминая о предыдущей версии программы в другом месте.</p>
<p>Исполнение команды <code>umask 022</code> гарантирует, что вновь созданные файлы и каталоги могут быть записаны только их владельцем, но могут быть прочитаны и исполнены любым пользователем.</p>
<p>Далее во избежание сбоев во время сборки кросс-компилятора нам требуется «удалить» переменную окружения <code>CFLAGS</code>.</p>
<p>Переменная окружения <code>LFA</code> содержит путь до дитректории, в которой будем собирать систему.</p>
<p><code>LC_ALL</code> управляет локализацией программ, заставляя сообщения, которые они выводят в терминал, следовать конвенциям указанной в этой переменной страны. Во избежание проблем сборки любые значения <code>LC_ALL</code>, отличные от <code>POSIX</code> или <code>C</code>, использовать не рекомендуется.</p>
<p>Переменная окружения <code>PATH</code> содержит пути до директорий, в которых содержатся исполняемые файлы. Благодаря этой переменной в терминале мы можем просто ввести <code>some_program</code> вместо указания полного пути <code>/usr/bin/some_program</code>. В эту переменную мы добавляем путь до двоичных исполняемых файлов собираемого нами кросс-компилятора (<code>$LFA/tools/bin</code>), а также «стандартные» для хост-системы директории <code>/bin</code> и <code>/usr/bin</code>. Указание пути до кросс-компилятора раньше, чем путей до других инструментов вкупе с отключением хеширования гарантирует, что для сборки системы у нас будут использованы только нужные программы из кросс-компилятора, а не из хост-системы.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Установка-переменных-сборки"><a class="header" href="#Установка-переменных-сборки">Установка переменных сборки</a></h1>
<p>В данной части будет произведена установка ряда важных переменных, которые будут использоваться для сборки программ. Определите, для какой архитектуры семейства ARM вы будете собирать систему и в зависимости от этого выбирайте набор нужных вам переменных. Обращаем ваше внимание на то, что LFA предназначена в первую очередь для процессоров с архитектурой AArch64. Работа LFA на других архитектурах не проверялась. Поддержка других архитектур оставлена здесь &quot;в наследие&quot; от оригинальной CLFS.</p>
<blockquote>
<p>То, что это <em>дополнительные</em> переменные окружения, совсем не значит, что они являются <em>необязательными</em>. Мы вынесли объявление этих переменных окружения в отдельную страницу потому, что на <a href="prepare/set-env.html">предыдущей странице</a> шла речь об общих переменных окружения. Переменные же на текцщей странице предназначены исключительно для сборки ПО. Кроме того, если для общих переменных существует один единственный шаблон, который можно использовать для всех сборок LFA, то значения для переменных на данной странице пользователь выбирает самостоятельно в зависимости от оборудования, для которого он собирает эту систему.</p>
</blockquote>
<h2 id="Хост-и-цель"><a class="header" href="#Хост-и-цель">Хост и цель</a></h2>
<p>Напомним вам, что такое хост-компьютер и целевой компьютер. <em>Хост-компьютер</em> (host) — это ПК, на котором вы собираете кросс-компилятор и прочие вещи. А <em>целевой компьютер</em> (target) — тот ПК, для которого вы это собираете. В данном руководстве хост-компьютером является компьютер на архитектуре x86_64, а целевым — компьютер на архитектуре AArch64.</p>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="prepare/set-build-env.html#admonition-Внимание"></a></p>
</div>
<div>
<blockquote>
<p>В настоящее время мы составляем <a href="prepare/../appendix/computers.html">список процессоров</a> (бренд процессора, модель процессора, его архитектура и модели ПК, где он применяется), в котором будут указаны полные сведения о том, какие значения используются для переменных <code>LFA_FPU</code>, <code>LFA_ARCH</code> и <code>LFA_TGT</code>.</p>
</blockquote>
<p>В случае, если вы собрали систему, используя определённые значения, то, пожалуйста, оставьте <a href="prepare/">запрос</a> в нашем репозитории GitHub по этому поводу. Укажите бренд процессора, еего модель и его архитектуру, а также модель компьютера, для которого вы собирали систему. Кроме того, совсем не лишним будет, если вы укажете, как собралась ваша система: собралась ли она корректно или были всевозможные ошибки в процессе сборки или в процессе её функционирования.</p>
<p><strong>Пример такого запроса (issue):</strong></p>
<pre><code class="language-md"># Сборка системы для компьютера Orange Pi 3 LTS

- **Бренд процессора:** Allwinner
- **Модель процессора:** Allwnner H6
- **Архитектура:** Cortex-A53 (AArch64)
- **Статус сборки:** система собралась нормально
- **Статус функционирования:** система работает корректно

## Значения переменных сборки

`LFA_TGT`=`aarch64-linux-musleabihf`

`LFA_HOST`=`...`

`LFA_ARCH`=`armv8-a`
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Для-архитектуры-aarch64"><a class="header" href="#Для-архитектуры-aarch64">Для архитектуры AArch64</a></h1>
<p>Для сборки кросс-компилятора вам нужно задать несколько переменных, которые будут зависеть от того, для какого оборудования вы хотите собрать LFA. Вам нужно выбрать триплет для целевой архитектуры, архитектуру процессора и т.д. Для выбора нужных значений пользуйтесь приведёнными на данной странице таблицами.</p>
<!-- Если ваш целевой процессор имеет аппаратную поддержку плавающей запятой, то установите переменную `LFA_FLOAT` в значение `hard` или `softfp`. Используйте `softfp`, если в будущем вы будете использовать в собранной системе ещё и программы, скомпилированные с помощью `soft`. В противном случае используйте `hard`. Если ваш целевой процессор не поддерживает плавающую запятую, используйте в качестве значения `LFA_FLOAT` `soft`:

```bash
export LFA_FLOAT="[hard, soft или softfp]"
```

Если вы выбрали `hard` или `softfp` для `LFA_FLOAT`, то теперь вам нужно установить, какое [оборудование для работы с плавающей запятой](../additional/fpu.md) используется в целевом процессоре (согласно таблице ниже):

```bash
export LFA_FPU="одно из значений из таблицы ниже"
```

| FPU | FPU | FPU | FPU |
|-----|-----|-----|-----|
| `fpa` | `fpe2` | `fpe3` | `maverick` |
| `vfp` | `vfpv3` | `vfpv3-fp16` | `vfpv3-d16` |
| `vfpv3-d16-fp16` | `vfpv3xd` | `vfpv3xd-fp16` | `neon` |
| `neon-fp16` | `vfpv4` | `vfpv4-d16` | `fpv4-sp-d16` |
| `neon-vfpv4` | | | | |

Например, для процессоров Cortex-A53 используется VFPv4. -->
<p>Установите триплеты для хоста и целевой машины:</p>
<pre><code class="language-bash">export LFA_HOST=$(echo ${MACHTYPE} | sed &quot;s/-[^-]*/-cross/&quot;)
export LFA_TGT=&quot;aarch64-linux-musleabihf&quot;
</code></pre>
<!-- 
export LFA_TGT="триплет для целевой машины"
-->
<!-- | Значение `$LFA_FLOAT` | Триплет                    |
|-----------------------|----------------------------|
| `soft` или `softfp`   | `aarch64-linux-musleabi`   |
| `hard`                | `aarch64-linux-musleabihf` | -->
<p>Выберите архитектуру, для которой будете собирать систему:</p>
<pre><code class="language-bash">export LFA_ARCH=&quot;архитектура&quot;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>ARCH</th><th>ARCH</th><th>ARCH</th><th>ARCH</th></tr></thead><tbody>
<tr><td><code>armv8-a</code></td><td><code>armv8-m</code></td><td><code>armv8</code></td><td><code>armv8-r</code></td></tr>
<tr><td><code>armv8.1-a</code></td><td><code>armv8.1-m</code></td><td><code>armv8.1-r</code></td><td></td></tr>
</tbody></table>
</div>
<p>Например, для процессоров Cortex-A53 <code>$LFA_ARCH=&quot;armv8-a&quot;</code>.</p>
<p>Запишите эти переменные в <code>~/.bashrc</code>, чтобы не вводить их значения каждый раз после входа от имени пользователя <code>lfa</code>:</p>
<pre><code class="language-bash">cat &gt;&gt; ~/.bashrc &lt;&lt; EOF
export LFA_HOST=&quot;$LFA_HOST&quot;
export LFA_TGT=&quot;$LFA_TGT&quot;
export LFA_ARCH=&quot;$LFA_ARCH&quot;
EOF
</code></pre>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="prepare/set-build-env-aarch64.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Далее и на протяжении всего руководства, если вы собираете систему для AArch64, то <strong>не используйте</strong> переменные окружения <code>$LFA_FLOAT</code> и <code>$LFA_FPU</code>, а также пропускайте при вводе команд строки, содержащие эти переменные окружения. Например, если вы собираете систему для AArch64, то скрипту <code>configure</code> не следует передавать эти аргументы:</p>
<pre><code class="language-bash">  --with-float=$LFA_FLOAT \
  --with-fpu=$LFA_FPU
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Для-других-архитектур"><a class="header" href="#Для-других-архитектур">Для других архитектур</a></h1>
<blockquote>
<p>Если ваш процессор — ARM9, хорошие варианты: триплет из <code>arm-linux-musleabi</code>, архитектура — <code>armv5t</code> и поддержка плавающей запятой — <code>soft</code>. ARM9-процессоры обычно не имеют аппаратных возможностей работы с плавающей запятой.</p>
</blockquote>
<p>Для сборки кросс-компилятора вам нужно задать несколько переменных, которые будут зависеть от того, для какого оборудования вы хотите собрать LFA. Вам нужно выбрать триплет для целевой архитектуры, архитектуру процессора и т.д. Для выбора нужных значений пользуйтесь приведёнными на данной странице таблицами.</p>
<p>Если ваш целевой процессор имеет аппаратную поддержку плавающей запятой, то установите переменную <code>LFA_FLOAT</code> в значение <code>hard</code> или <code>softfp</code>. Используйте <code>softfp</code>, если в будущем вы будете использовать в собранной системе ещё и программы, скомпилированные с помощью <code>soft</code>. В противном случае используйте <code>hard</code>. Если ваш целевой процессор не поддерживает плавающую запятую, используйте в качестве значения <code>LFA_FLOAT</code> <code>soft</code>:</p>
<pre><code class="language-bash">export LFA_FLOAT=&quot;[hard, soft или softfp]&quot;
</code></pre>
<p>Если вы выбрали <code>hard</code> или <code>softfp</code> для <code>LFA_FLOAT</code>, то теперь вам нужно установить, какое <a href="prepare/../additional/fpu.html">оборудование для работы с плавающей запятой</a> используется в целевом процессоре (согласно таблице ниже):</p>
<pre><code class="language-bash">export LFA_FPU=&quot;одно из значений из таблицы ниже&quot;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>FPU</th><th>FPU</th><th>FPU</th><th>FPU</th></tr></thead><tbody>
<tr><td><code>fpa</code></td><td><code>fpe2</code></td><td><code>fpe3</code></td><td><code>maverick</code></td></tr>
<tr><td><code>vfp</code></td><td><code>vfpv3</code></td><td><code>vfpv3-fp16</code></td><td><code>vfpv3-d16</code></td></tr>
<tr><td><code>vfpv3-d16-fp16</code></td><td><code>vfpv3xd</code></td><td><code>vfpv3xd-fp16</code></td><td><code>neon</code></td></tr>
<tr><td><code>neon-fp16</code></td><td><code>vfpv4</code></td><td><code>vfpv4-d16</code></td><td><code>fpv4-sp-d16</code></td></tr>
<tr><td><code>neon-vfpv4</code></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Установите триплеты для хоста и целевой машины:</p>
<pre><code class="language-bash">export LFA_HOST=$(echo ${MACHTYPE} | sed &quot;s/-[^-]*/-cross/&quot;)
export LFA_TGT=&quot;триплет для целевой машины&quot;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Значение <code>$LFA_FLOAT</code></th><th>Триплет</th></tr></thead><tbody>
<tr><td><code>soft</code> или <code>softfp</code></td><td><code>arm-linux-musleabi</code></td></tr>
<tr><td><code>hard</code></td><td><code>arm-linux-musleabihf</code></td></tr>
</tbody></table>
</div>
<p>Выберите архитектуру, для которой будете собирать систему:</p>
<pre><code class="language-bash">export LFA_ARCH=&quot;архитектура&quot;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>ARCH</th><th>ARCH</th><th>ARCH</th><th>ARCH</th></tr></thead><tbody>
<tr><td><code>armv4t</code></td><td><code>armv5t</code></td><td><code>armv5te</code></td><td><code>armv6</code></td></tr>
<tr><td><code>armv6j</code></td><td><code>armv6k</code></td><td><code>armv6kz</code></td><td><code>armv6t2</code></td></tr>
<tr><td><code>armv6z</code></td><td><code>armv6-m</code></td><td><code>armv7</code></td><td><code>armv7-a</code></td></tr>
<tr><td><code>armv7-r</code></td><td><code>armv7-m</code></td><td><code>armv9-a</code></td><td><code>armv9</code></td></tr>
</tbody></table>
</div>
<p>Запишите эти переменные в <code>~/.bashrc</code>, чтобы не вводить их значения каждый раз после входа от имени пользователя <code>lfa</code>:</p>
<pre><code class="language-bash">cat &gt;&gt; ~/.bashrc &lt;&lt; EOF
export LFA_HOST=&quot;$LFA_HOST&quot;
export LFA_TGT=&quot;$LFA_TGT&quot;
export LFA_ARCH=&quot;$LFA_ARCH&quot;
export LFA_FLOAT=&quot;$LFA_FLOAT&quot;
export LFA_FPU=&quot;$LFA_FPU&quot;
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-основных-каталогов"><a class="header" href="#Создание-основных-каталогов">Создание основных каталогов</a></h1>
<p>Создайте каталог, в котором будет содержаться файлы кросс-компилятора. Для того, чтобы постоянно не указывать путь до него при сборке пакетов, объявите новую переменную окружения <code>$LFA_CROSS</code>:</p>
<pre><code class="language-bash">export LFA_CROSS=$LFA/tools/$LFA_TGT

mkdir -pv $LFA_CROSS
ln -svf . $LFA_CROSS/usr

echo &quot;export LFA_CROSS=\$LFA/tools/\$LFA_TGT&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>Кроме того, вам необходимо создать директорию, где будет храниться исходный код компонентов:</p>
<pre><code class="language-bash">mkdir -v src
</code></pre>
<p>В итоге в домашней папке пользователя <code>lfa</code> будет примерно такая структура файлов:</p>
<pre><code>/home/lfa
|-- lfa/
|   `-- tools/
|       `-- aarch64-linux-musleabihf/
|           `-- usr/ -&gt; .
`-- src/
</code></pre>
<p>И содержимое файла <code>~/.bashrc</code> после всех записей в него (в зависимости от выбранной вами архитектуры его содержимое может незначительно меняться):</p>
<pre><code class="language-bash">set +h
umask 022
unset CFLAGS
LFA=$HOME/lfa
LC_ALL=C
PATH=$LFA/tools/bin:/bin:/usr/bin
export LFA LC_ALL PATH
export LFA_HOST=&quot;x86_64-cross-linux-gnu&quot;
export LFA_TGT=&quot;aarch64-linux-musleabihf&quot;
export LFA_ARCH=&quot;armv8-a&quot;
export LFA_CROSS=$LFA/tools/$LFA_TGT
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Скачивание-пакетов"><a class="header" href="#Скачивание-пакетов">Скачивание пакетов</a></h1>
<p>Перейдите в директорию <code>src/</code>, которую вы создали ранее:</p>
<pre><code class="language-bash">cd src/
</code></pre>
<p>Скачайте файлы <code>wget-list</code> и <code>md5sums</code>, которые будут использованы для скачивания исходного кода компонентов системы:</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/Linux-for-ARM/handbook/master/wget-list
wget https://raw.githubusercontent.com/Linux-for-ARM/handbook/master/md5sums
</code></pre>
<p>И скачайте системные компоненты:</p>
<pre><code class="language-bash">wget --input-file=wget-list --continue
</code></pre>
<p>Для проверки корректности скачивания пакетов вам нужно воспользоваться файлом <code>md5sums</code>:</p>
<pre><code class="language-bash">md5sum -c md5sums
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-кросс-компилятора"><a class="header" href="#Сборка-кросс-компилятора">Сборка кросс-компилятора</a></h1>
<p>В данной главе вы соберёте кросс-компилятор, необходимый для дальнейшей сборки LFA. Подробные сведения о том, зачем это нужно, вы можете получить в <a href="cross-compiler/../additional/cross-compiler.html">дополнительных материалах</a>.</p>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/index.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Перед выполнением инструкций по сборке пакета необходимо распаковать его от имени пользователя <code>lfa</code> и перейти в распакованную директорию с исходным кодом пакета (обычно директория имеет то же имя, что и архив с исходниками, но без расширения <code>.tar.*</code>) с помощью команды <code>cd ИМЯ_ДИРЕКТОРИИ</code>. В инструкциях по сборке предполагается, что используется командная оболочка BASH или совместимая с ней.</p>
</div>
</div>
<blockquote>
<p>Во время компиляции большинства пакетов на экран будут выводиться различные сообщения, в том числе и предупреждения. Это предупреждения как правило об устаревшем использовании синтаксиса языка программирования С. Это не является проблемой, но вызывает предупреждение.</p>
</blockquote>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/index.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>После установки пакета как в этой, так и в следующих главах, перейдите обратно в директорию <code>src/</code> (командой <code>cd ..</code> или <code>cd ../..</code> если сборка производилась в отдельной директории), а затем удалите каталог, в котором вы собирали этот пакет.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-headers"><a class="header" href="#linux-headers">linux-headers</a></h1>
<blockquote>
<p>Заголовочные файлы ядра Linux, необходимые для сборки кросс-компилятора</p>
<ul>
<li><strong>Версия:</strong> 6.6.6</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.kernel.org">https://www.kernel.org</a></li>
<li><strong>Время сборки:</strong> 0.5 ОВС</li>
</ul>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/linux-headers.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Обратите внимание, что исходный код <code>linux-headers</code> содержится в архиве с ядром Linux-6.6.6</p>
</div>
</div>
<h2 id="Настройка"><a class="header" href="#Настройка">Настройка</a></h2>
<p>Убедитесь, что дерево исходного кода Linux чистое и не содержит лишних файлов:</p>
<pre><code class="language-bash">make mrproper
</code></pre>
<h2 id="Установка"><a class="header" href="#Установка">Установка</a></h2>
<pre><code class="language-bash">make ARCH=arm64 INSTALL_HDR_PATH=$LFA_CROSS headers_install
</code></pre>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/linux-headers.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Обратите внимание на аргумент <code>ARCH=arm64</code>. Для 32-битных процессоров нужно заменить этот аргумент на <code>ARCH=arm</code>.</p>
<p>Например, если ваш процессор имеет 64-битную архитектуру (ARMv8 или ARMv8.1), то оставьте этот аргумент без изменений. Однако если у вас иная 32-битная архитектура, то замените <code>ARCH=arm64</code> на <code>ARCH=arm</code>.</p>
</div>
</div>
<blockquote>
<p>Если во время установки заголовков ядра (в частности, при исполнении второй команды <code>headers_install</code>) у вас возникли ошибки, проверьте, установлена ли в системе программа <code>rsync</code>.</p>
</blockquote>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>ARCH=arm64</code> - указывает <code>make</code> устанавливать заголовки для архитектуры <code>arm64</code>.</p>
<p><code>INSTALL_HDR_PATH=$LFA_CROSS</code> - указывает <em>префикс</em>, в который будут установлены заголовки.</p>
</blockquote>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="cross-compiler/linux-headers.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные заголовки:</strong> <code>$LFA_CROSS/include/{asm,asm-generic,drm,linux,misc,mtd,rdma,scsi,sound,video,xen}/*.h</code></li>
</ul>
<h3 id="Описание-компонентов"><a class="header" href="#Описание-компонентов">Описание компонентов</a></h3>
<ul>
<li><code>$LFA_CROSS/include/asm/*.h</code> - заголовки Linux API ASM.</li>
<li><code>$LFA_CROSS/include/asm-generic/*.h</code> - общие заголовки Linux API ASM.</li>
<li><code>$LFA_CROSS/include/drm/*.h</code> - заголовки Linux DRM.</li>
<li><code>$LFA_CROSS/include/linux/*.h</code> - заголовки Linux API.</li>
<li><code>$LFA_CROSS/include/misc/*.h</code> - различные заголовки Linux API.</li>
<li><code>$LFA_CROSS/include/mtd/*.h</code> - заголовки Linux API MTD.</li>
<li><code>$LFA_CROSS/include/rdma/*.h</code> - заголовки Linux API RDMA.</li>
<li><code>$LFA_CROSS/include/scsi/*.h</code> - заголовки Linux API SCSI.</li>
<li><code>$LFA_CROSS/include/sound/*.h</code> - заголовки Linux API для работы со звуком.</li>
<li><code>$LFA_CROSS/include/video/*.h</code> - заголовки Linux API для работы с видео.</li>
<li><code>$LFA_CROSS/include/xen/*.h</code> - заголовки Linux API XEN.</li>
</ul>
</div>
</details>
<hr />
<blockquote>
<p><strong>Смотрите также:</strong></p>
<ul>
<li><a href="cross-compiler/../additional/compile.html">Сборка ПО из исходного кода</a></li>
<li><a href="cross-compiler/../additional/cross-compiler.html">Кросс-компилятор</a></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binutils"><a class="header" href="#binutils">binutils</a></h1>
<blockquote>
<p>Этот пакет содержит компоновщик, ассемблер и другие утилиты для работы с объектными файлами.</p>
<ul>
<li><strong>Версия:</strong> 2.42</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.gnu.org/software/binutils">https://www.gnu.org/software/binutils</a></li>
<li><strong>Время сборки:</strong> 1 ОВС</li>
</ul>
</blockquote>
<h2 id="Настройка-1"><a class="header" href="#Настройка-1">Настройка</a></h2>
<p>Сборка пакета <code>binutils</code> должна происходить в отдельном каталоге. Создайте его:</p>
<pre><code class="language-bash">mkdir -v build
cd build
</code></pre>
<p>Запустите скрипт <code>configure</code> для генерации предназначенных для сборки файлов <code>Makefile</code>:</p>
<pre><code class="language-bash">../configure --prefix=$LFA/tools \
  --target=$LFA_TGT \
  --with-sysroot=$LFA_CROSS \
  --disable-nls \
  --enable-gprofng=no \
  --disable-werror \
  --disable-multilib
</code></pre>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>--prefix=$LFA/tools</code> - указывает скрипту <code>configure</code> подготовиться к установке пакета в директорию <code>$LFA/tools</code>.</p>
<p><code>--target=$LFA_TGT</code> - создаёт кросс-архитектурный исполняемый файл, который запускается на x86_64-системе, но создаёт файлы для <code>$LFA_TGT</code>-архитектуры.</p>
<p><code>--with-sysroot=$LFA_CROSS</code> - сообщает <code>configure</code>, что <code>$LFA_CROSS</code> будет корнем кросс-компилятора.</p>
<p><code>--disable-nls</code> - отключает сборку пакета с поддержкой интернационализации и локализации. В кросс-компиляторе это не нужно.</p>
<p><code>--enable-gprofng=no</code> - отключает сборку <code>gprofng</code>, который не нужен в кросс-компиляторе.</p>
<p><code>--disable-werror</code> - отключает остановку сборку при возникновении предупреждений.</p>
<p><code>--disable-multilib</code> - отключает сборку multilib.</p>
</blockquote>
<h2 id="Сборка"><a class="header" href="#Сборка">Сборка</a></h2>
<pre><code class="language-bash">make configure-host
make
</code></pre>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>make configure-host</code> - проверяет окружение хоста и убеждается, что все необходимые инструменты доступны для компиляции <code>bintuils</code>.</p>
</blockquote>
<h2 id="Установка-1"><a class="header" href="#Установка-1">Установка</a></h2>
<pre><code class="language-bash">make install
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="cross-compiler/binutils.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>addr2line</code>, <code>ar</code>, <code>as</code>, <code>c+filt</code>, <code>elfedit</code>, <code>gprof</code>, <code>ld</code>, <code>nm</code>, <code>objcopy</code>, <code>objdump</code>, <code>ranlib</code>, <code>readelf</code>, <code>size</code>, <code>strings</code>, <code>strip</code>.</li>
<li><strong>Установленные библиотеки:</strong> <code>libibery.a</code>, <code>libbbfd.{a,so}</code>, <code>libopcodes.{a,so}</code></li>
</ul>
<h3 id="Описание-компонентов-1"><a class="header" href="#Описание-компонентов-1">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>addr2line</code> - транслирует адреса программ в имена файлов и номера строк. Если задан адрес и имя исполняемого файла, он использует отладочную информацию в нём, чтобы определить, какой исходный файл или номер строки связаны с этим адресом.</li>
<li><code>ar</code> - создаёт, изменяет и распаковывает ar-архивы.</li>
<li><code>as</code> - GNU-ассемблер, который используется, в частности, в <code>gcc</code>.</li>
<li><code>c++filt</code> - используется компоновщиком для &quot;распутывания&quot; символов C++ и Java и предотвращения столкновения перегруженных функций.</li>
<li><code>elfedit</code> - получает и изменяет метаданные ELF-файлов.</li>
<li><code>gprof</code> - отображение данных профиля графика вызовов.</li>
<li><code>ld</code> - компоновщик, который объединяет несколько объектных и архивных файлов в один файл, перемещая их данные и связывая символьные ссылки.</li>
<li><code>nm</code> - перечисляет символы, встречающиеся в данном объектном файле.</li>
<li><code>objcopy</code> - копирует содержимое одного объектного файла в другой.</li>
<li><code>objdump</code> - отображает информацию о данном объектном файле.</li>
<li><code>ranlib</code> - генерирует индекс содержимого архива и сохраняет его в архиве.</li>
<li><code>readelf</code> - отображает информацию об ELF-файле.</li>
<li><code>size</code> - перечисляет размеры секций ELF-файла и размер для заданных файлов объектов.</li>
<li><code>strings</code> -  выводит для каждого заданного файла последовательности печатаемых символов, длина которых не меньше указанной (по умолчанию - четыре); для объектных файлов по умолчанию выводятся только строки из секций инициализации и загрузки, а для других типов файлов сканируется весь файл.</li>
<li><code>strip</code> - удаляет символы из объектных файлов.</li>
</ul>
</li>
<li><strong>Библиотеки:</strong>
<ul>
<li><code>libiberty</code> - содержит функции, используемые различными программами GNU, включая <code>getopt</code>, <code>obstack</code>, <code>strerror</code>, <code>strtoul</code>.</li>
<li><code>libbfd</code> - библиотека дескрипторов двоичных файлов.</li>
<li><code>libopcodes</code> - библиотека для работы с опкодами - &quot;читабельными текстовыми&quot; версиями инструкций для процессора. Используется, например, в <code>objdump</code>.</li>
</ul>
</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcc-проход-1"><a class="header" href="#gcc-проход-1">gcc (проход 1)</a></h1>
<blockquote>
<p>Набор компиляторов GNU GCC.</p>
<ul>
<li><strong>Версия:</strong> 13.2.0</li>
<li><strong>Домашняя страница:</strong> <a href="https://gcc.gnu.org">https://gcc.gnu.org</a></li>
<li><strong>Время сборки:</strong> 14.8 ОВС</li>
</ul>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p1.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Сейчас нам нужно собрать GCC со статической библиотекой <code>libgcc</code> и без поддержки многопоточности. Этот первый проход сборки делается главным образом для того, чтобы мы могли собрать с помощью этого компилятора стандартную библиотеку C (<code>musl</code>).</p>
</div>
</div>
<h2 id="Подготовка"><a class="header" href="#Подготовка">Подготовка</a></h2>
<p>GCC требует, чтобы пакеты GMP, MPFR и MPC либо присутствовали на хосте, либо представлены в виде исходных текстов в дереве исходного кода GCC. Распакуйте их:</p>
<pre><code class="language-bash">tar -xf ../gmp-6.3.0.tar.xz
tar -xf ../mpc-1.3.1.tar.gz
tar -xf ../mpfr-4.2.1.tar.xz

mv -v gmp-6.3.0 gmp
mv -v mpc-1.3.1 mpc
mv -v mpfr-4.2.1 mpfr
</code></pre>
<h2 id="Настройка-2"><a class="header" href="#Настройка-2">Настройка</a></h2>
<p>Сборка пакета <code>gcc</code> должна происходить в отдельном каталоге. Создайте его:</p>
<pre><code class="language-bash">mkdir -v build
cd build
</code></pre>
<p>Запустите скрипт <code>configure</code>:</p>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p1.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Далее и на протяжении всего руководства, если вы собираете систему для AArch64, то <strong>не используйте</strong> переменные окружения <code>$LFA_FLOAT</code> и <code>$LFA_FPU</code>, а также пропускайте при вводе команд строки, содержащие эти переменные окружения. Например, если вы собираете систему для AArch64, то скрипту <code>configure</code> не следует передавать эти аргументы:</p>
<pre><code class="language-bash">  --with-float=$LFA_FLOAT \
  --with-fpu=$LFA_FPU
</code></pre>
</div>
</div>
<pre><code class="language-bash">../configure --prefix=$LFA/tools \
  --build=$LFA_HOST \
  --host=$LFA_HOST \
  --target=$LFA_TGT \
  --with-sysroot=$LFA_CROSS \
  --disable-nls \
  --disable-shared \
  --without-headers \
  --with-newlib \
  --enable-default-pie \
  --enable-default-ssp \
  --disable-decimal-float \
  --disable-libgomp \
  --disable-libmudflap \
  --disable-libssp \
  --disable-libvtv \
  --disable-libstdcxx \
  --disable-libatomic \
  --disable-libquadmath \
  --disable-threads \
  --enable-languages=c \
  --disable-multilib \
  --with-arch=$LFA_ARCH \
  --with-float=$LFA_FLOAT \
  --with-fpu=$LFA_FPU
</code></pre>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>--host=$LFA_HOST</code> - указывает <code>configure</code> триплет машины, на которой будет выполняться GCC при кросс-компиляции. <code>$LFA_HOST</code> содержит название архитектуры хоста, на которой будем производить кросс-компиляцию для архитектуры <code>$LFA_TGT</code>.</p>
<p><code>--disable-shared</code> - этот переключатель заставляет GCC связывать свои внутренние библиотеки статически.</p>
<p><code>--without-headers</code> - указывает <code>configure</code> не использовать никаких заголовков из библиотек С. Это необходимо, поскольку мы ещё не собрали библиотеку С и чтобы предотвратить влияние окружения хоста.</p>
<p><code>--with-newlib</code> - собрать <code>libgcc</code> без использования библиотек С.</p>
<p><code>--enable-default-pie</code>, <code>--enable-default-ssp</code> - позволяют GCC по умолчанию компилировать программы с некоторыми средствами усиления безопасности.</p>
<p><code>--disable-decimal-float</code> - отключить поддеркжу десятичной плавающей запятой (IEEE 754-2008). Нам это пока не нужно.</p>
<p><code>--disable-libgomp</code> - не собирать библиотеки времени выполнения GOMP.</p>
<p><code>--disable-libmudflap</code> - не собирать библиотеку <code>libmudflap</code> (библиотека, которая может быть использована для проверки правильности использования указателей).</p>
<p><code>--disable-libssp</code> - не собирать библиотеки времени выполнения для обнаружения разбиения стека.</p>
<p><code>--disable-libvtv</code> - не собирать <code>libvtv</code>.</p>
<p><code>--disable-libstdcxx</code> - не собирать стандартную библиотеку C++.</p>
<p><code>--disable-libatomic</code> - не собирать атомарные операции.</p>
<p><code>--disable-libquadmath</code> - не собирать <code>libquadmath</code>.</p>
<p><code>--disable-threads</code> - не искать многопоточные заголовочные файлы, поскольку для этой архитектуры (<code>$LFA_TGT</code>) их ещё нет. GCC сможет найти их после сборки стандартной библиотеки С.</p>
<p><code>--enable-languages=c</code> - указывает <code>configure</code> собирать компилятр языка C.</p>
<p><code>--disable-multilib</code> - поддержка multilib нам не нужна.</p>
<p><code>--with-arch=$LFA_ARCH</code> - устанавливает выбранную ранее архитектуру ARM.</p>
<p><code>--with-float=$LFA_FLOAT</code> - устанавливает ранее выбранный режим работы с плавающей запятой.</p>
<p><code>--with-fpu=$LFA_FPU</code> - устанавливает тип аппаратной плавающей запятой. Если <code>$LFA_FPU=&quot;soft&quot;</code>, это значение игнорируется.</p>
</blockquote>
<h2 id="Сборка-1"><a class="header" href="#Сборка-1">Сборка</a></h2>
<pre><code class="language-bash">make all-gcc all-target-libgcc
</code></pre>
<h2 id="Установка-2"><a class="header" href="#Установка-2">Установка</a></h2>
<pre><code class="language-bash">make install-gcc install-target-libgcc
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p1.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<p>На данный момент знать содержимое пакета GCC вам не требуется, поскольку сейчас мы собрали лишь небольшую его часть, предназначенную только для компиляции стандартной библиотеки С (<code>musl</code>). Информация о содержимом пакета GCC содержится <a href="cross-compiler/gcc-p2.html">на втором проходе сборки GCC</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="musl"><a class="header" href="#musl">musl</a></h1>
<blockquote>
<p>Минималистичная стандартная библиотека языка С.</p>
<ul>
<li><strong>Версия:</strong> 1.2.5</li>
<li><strong>Домашняя страница:</strong> <a href="https://musl.libc.org">https://musl.libc.org</a></li>
<li><strong>Время сборки:</strong> 5.4 ОВС</li>
</ul>
</blockquote>
<h2 id="Настройка-3"><a class="header" href="#Настройка-3">Настройка</a></h2>
<pre><code class="language-bash">./configure CROSS_COMPILE=$LFA_TGT- \
  --prefix=/ \
  --target=$LFA_TGT
</code></pre>
<h2 id="Сборка-2"><a class="header" href="#Сборка-2">Сборка</a></h2>
<pre><code class="language-bash">make
</code></pre>
<h2 id="Установка-3"><a class="header" href="#Установка-3">Установка</a></h2>
<pre><code class="language-bash">make DESTDIR=$LFA_CROSS install
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="cross-compiler/musl.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>ld-musl</code></li>
<li><strong>Установленные библиотеки:</strong> <code>libc.so.0</code>, <code>libcrypt.so.0</code>, <code>libdl.so.0</code>, <code>libm.so.0</code>, <code>libpthread.so.0</code>, <code>librt.so.0</code></li>
</ul>
<h3 id="Описание-компонентов-2"><a class="header" href="#Описание-компонентов-2">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>ld-musl</code> - динамический компоновщик/загрузчик musl.</li>
</ul>
</li>
<li><strong>Библиотеки:</strong>
<ul>
<li><code>libc</code> - библиотека языка C.</li>
<li><code>libcrypt</code> - криптографическая библиотека.</li>
<li><code>libdl</code> - библиотека для динамического компоновщика/зарузчика.</li>
<li><code>libm</code> - математическая библиотека.</li>
<li><code>libpthread</code> - библиотека потоков POSIX.</li>
<li><code>librt</code> - библиотека часов и таймера.</li>
</ul>
</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcc-проход-2"><a class="header" href="#gcc-проход-2">gcc (проход 2)</a></h1>
<blockquote>
<p>Набор компиляторов GNU GCC.</p>
<ul>
<li><strong>Версия:</strong> 13.2.0</li>
<li><strong>Домашняя страница:</strong> <a href="https://gcc.gnu.org">https://gcc.gnu.org</a></li>
<li><strong>Время сборки:</strong> 14.8 ОВС</li>
</ul>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p2.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Сейчас мы собираем полноценную версию компилятора GCC для сборки остальной системы, используя уже готовую стандартную библиотеку С.</p>
</div>
</div>
<h2 id="Подготовка-1"><a class="header" href="#Подготовка-1">Подготовка</a></h2>
<pre><code class="language-bash">tar -xf ../gmp-6.3.0.tar.xz
tar -xf ../mpc-1.3.1.tar.gz
tar -xf ../mpfr-4.2.1.tar.xz

mv -v gmp-6.3.0 gmp
mv -v mpc-1.3.1 mpc
mv -v mpfr-4.2.1 mpfr
</code></pre>
<h2 id="Настройка-4"><a class="header" href="#Настройка-4">Настройка</a></h2>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p2.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Если вы собираете систему для AArch64, то <strong>не используйте</strong> переменные окружения <code>$LFA_FLOAT</code> и <code>$LFA_FPU</code>, а также пропускайте при вводе команд строки, содержащие эти переменные окружения. Например, если вы собираете систему для AArch64, то скрипту <code>configure</code> не следует передавать эти аргументы:</p>
<pre><code class="language-bash">  --with-float=$LFA_FLOAT \
  --with-fpu=$LFA_FPU
</code></pre>
</div>
</div>
<pre><code class="language-bash">mkdir -v build
cd build

../configure --prefix=$LFA/tools \
  --build=$LFA_HOST \
  --host=$LFA_HOST \
  --target=$LFA_TGT \
  --with-sysroot=$LFA_CROSS \
  --disable-nls \
  --enable-languages=c \
  --enable-c99 \
  --enable-long-long \
  --disable-libmudflap \
  --disable-multilib \
  --with-arch=$LFA_ARCH \
  --with-float=$LFA_FLOAT \
  --with-fpu=$LFA_FPU
</code></pre>
<h2 id="Сборка-3"><a class="header" href="#Сборка-3">Сборка</a></h2>
<pre><code class="language-bash">make
</code></pre>
<h2 id="Установка-4"><a class="header" href="#Установка-4">Установка</a></h2>
<pre><code class="language-bash">make install
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="cross-compiler/gcc-p2.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>gcc</code>, <code>gcov</code></li>
<li><strong>Установленные библиотеки:</strong> <code>libgcc.a</code>, <code>libgcc_eh.a</code>, <code>libgcc_s.so</code></li>
</ul>
<h3 id="Описание-компонентов-3"><a class="header" href="#Описание-компонентов-3">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>gcc</code> - компилятор языка C.</li>
<li><code>gcov</code> - инструмент для тестирования покрытия, используется для анализа программ, чтобы определить, где оптимизация даст наибольший эффект.</li>
</ul>
</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Проверка-кросс-компилятора"><a class="header" href="#Проверка-кросс-компилятора">Проверка кросс-компилятора</a></h1>
<p>На данном этапе необходимо убедиться, что установленные ранее пакеты работают правильно. Внимательно изучите результаты вывода команд, и проверьте, что они строго соответствуют результатам вывода, приведенным ниже. Если есть несоответствия, значит инструкции на предыдущих этапах были выполнены некорректно.</p>
<p>Проверьте, используется ли правильный загрузчик программ:</p>
<pre><code class="language-bash">echo &quot;int main() {}&quot; &gt; main.c

$LFA_TGT-gcc -xc main.c
readelf -l a.out | grep &quot;program interpreter&quot;
</code></pre>
<p>Вывод должен быть таким:</p>
<pre><code>      [Requesting program interpreter: /lib/ld-musl-aarch64.so.1]
</code></pre>
<blockquote>
<p>Если вы собирали систему для другой архитектуры семейства ARM, то различие будет в подстроке <code>ld-musl-aarch64.so.1</code>: вместо <code>aarch64</code> должно быть имя той архитектуры, для которой предназначен кросс-компилятор.</p>
</blockquote>
<p>Если вывод не такой, как показано выше, или его вообще нет, значит, что что-то пошло не так. Исследуйте и проследите все шаги сборки всех пакетов до этого этапа, чтобы найти причину проблемы и устранить её. Прежде чем продолжать сборку LFA, необходимо решить эту проблему.</p>
<p>Удалите тестовый файл:</p>
<pre><code class="language-bash">rm -v a.out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Очистка-и-сохранение"><a class="header" href="#Очистка-и-сохранение">Очистка и сохранение</a></h1>
<h2 id="Удаление-лишних-файлов"><a class="header" href="#Удаление-лишних-файлов">Удаление лишних файлов</a></h2>
<p>Сборка кросс-компилятора завершена. Теперь нужно очистить директорию с исходным кодом (<code>~/src</code>) от лишних подкаталогов, образовавшихся во время сборки. Выполните команду:</p>
<pre><code class="language-bash">for f in *; do
  if [ -d $f ]; then
    rm -rf $f
  fi
done
</code></pre>
<p>Эта команда удалит все директории в <code>src/</code>, оставив только архивы с исходным кодом ПО.</p>
<blockquote>
<p><strong>Значения новых параметров:</strong></p>
<p><code>for f in *</code> - символ <code>*</code> в данном случае означает &quot;все файлы в текущей директории&quot;. Мы проходимся по содержимому <code>src/</code> для удаления лишних файлов.</p>
<p><code>if [ -d $f ]</code> - выполняем проверку того, что файл <code>$f</code> - это директория. Поскольку мы удаляем распакованные из архивов директории, то нам нужно удалить только их, оставив архивы с исходным кодом не тронутыми.</p>
<p><code>rm -rf $f</code> - если <code>$f</code> - директория, то удалить её.</p>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="cross-compiler/cleanup.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Не удаляйте саму директорию <code>$LFA/tools</code>. Кросс-компилятор будет удалён только после окончания сборки базовой системы. В случае, если после сборки базовой системы вы захотите собрать дополнительное ПО, которое не описано в этом руководстве, то сборка будет также производиться посредством этого кросс-компилятора, поэтому не удаляйте его до тех пор, пока не окончите сборку всех необходимых вам программ.</p>
</div>
</div>
<h2 id="Сохранение"><a class="header" href="#Сохранение">Сохранение</a></h2>
<p>Если вы собираетесь использовать этот кросс-компилятор для последующих сборок системы LFA, то рекомендуем вам сделать его резервную копию:</p>
<pre><code class="language-bash">cd $LFA
tar -cJpf $HOME/lfa-cross-compiler-1.0.tar.xz .
</code></pre>
<p>Этой командой вы создадите архив <code>/home/lfa/lfa-cross-compiler-1.0.tar.xz</code> с содержимым директории <code>/home/lfa/lfa</code>, которая содержит в подкаталоге <code>tools/</code> кросс-компилятор. <em>В архив не будет добавлен исходный код компонентов системы, поскольку он находится в другой директории (<code>/home/lfa/src/</code>).</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Объявление-дополнительных-переменных"><a class="header" href="#Объявление-дополнительных-переменных">Объявление дополнительных переменных</a></h1>
<p>Теперь вам нужно объявить переменную <code>$LFA_SYS</code>, которая будет содержать путь до директории, в которой будет находиться собираемая базовая система LFA:</p>
<pre><code class="language-bash">export LFA_SYS=$LFA/baseOS
echo &quot;export LFA_SYS=\$LFA/baseOS&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>Объявите переменные, содержащие пути до собранных компилятора, компоновщика и иных инструментов:</p>
<pre><code class="language-bash">cat &gt;&gt; ~/.bashrc &lt;&lt; EOF
export CC=&quot;$LFA_TGT-gcc --sysroot=$LFA_SYS&quot;
export CXX=&quot;$LFA_TGT-g++ --sysroot=$LFA_SYS&quot;
export AR=&quot;$LFA_TGT-ar&quot;
export AS=&quot;$LFA_TGT-as&quot;
export LD=&quot;$LFA_TGT-ld --sysroot=$LFA_SYS&quot;
export RANLIB=&quot;$LFA_TGT-ranlib&quot;
export READELF=&quot;$LFA_TGT-readelf&quot;
export STRIP=&quot;$LFA_TGT-strip&quot;
EOF
</code></pre>
<p>И примените изменения:</p>
<pre><code class="language-bash">source ~/.bashrc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-базовой-системы"><a class="header" href="#Сборка-базовой-системы">Сборка базовой системы</a></h1>
<p>В этой главе мы начинаем всерьёз собирать систему LFA, используя кросс-компилятор из предыдущей главы. Порядок установки пакетов в этой главе должен строго соблюдаться, чтобы ни одна программа случайно не приобрела путь, ссылающийся на кросс-компилятор. По этой же причине не собирайте пакеты параллельно. Сборка сразу нескольких пакетов за раз хоть и уменьшит общее время сборки LFA, но это приведёт к неправильной компиляции и, как следствие, неработоспособности базовой ОС.</p>
<p>Если вы хотите ускорить сборку системы, то лучше использовать многопоточную сборку пакетов. Для этого добавьте к команде <code>make</code> ключ <code>-jN</code>, где <code>N</code> - число потоков вашего процессора. Например:</p>
<pre><code class="language-bash">make -j4
</code></pre>
<p>Кроме того, чтобы каждый раз не указывать <code>-jN</code>, вы можете объявить переменную окружения <code>MAKEFLAGS</code>, содержащую эту опцию:</p>
<pre><code class="language-bash">export MAKEFLAGS=&quot;-jN&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-файлов-и-каталогов"><a class="header" href="#Создание-файлов-и-каталогов">Создание файлов и каталогов</a></h1>
<h2 id="Директория-базовой-ОС"><a class="header" href="#Директория-базовой-ОС">Директория базовой ОС</a></h2>
<p>Создайте директорию, в которой будут находиться файлы собранной базовой ОС:</p>
<pre><code class="language-bash">mkdir -pv $LFA_SYS
</code></pre>
<h2 id="Стандартные-системные-каталоги-базовой-ОС"><a class="header" href="#Стандартные-системные-каталоги-базовой-ОС">Стандартные системные каталоги базовой ОС</a></h2>
<p>Теперь пришло время создать некоторую структуру в целевой файловой системе базовой ОС. Создайте стандартное дерево каталогов, выполнив следующие команды:</p>
<pre><code class="language-bash">mkdir -pv $LFA_SYS/{bin,boot,dev,etc,home}
mkdir -pv $LFA_SYS/lib/{firmware,modules}
mkdir -pv $LFA_SYS/{mnt,opt,proc,sbin,srv,sys}
mkdir -pv $LFA_SYS/var/{cache,lib,local,lock,log,opt,run,spool}
mkdir -pv $LFA_SYS/usr/{,local/}{bin,include,lib,sbin,share,src}

install -dv -m 0750 $LFA_SYS/root
install -dv -m 1777 $LFA_SYS/{var/,}tmp
</code></pre>
<details id="admonition-Проверьте-себя" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Проверьте себя</p>
<p><a class="admonition-anchor-link" href="base/create-files.html#admonition-Проверьте-себя"></a></p>
</summary>
<div>
<p>После исполнения данных команд в директории <code>$LFA_SYS</code> должна быть такая структура:</p>
<pre><code>/home/lfa/lfa/baseOS
|-- bin
|-- boot
|-- dev
|-- etc
|-- home
|-- lib
|   |-- firmware
|   `-- modules
|-- mnt
|-- opt
|-- proc
|-- root
|-- sbin
|-- srv
|-- sys
|-- tmp
|-- usr
|   |-- bin
|   |-- include
|   |-- lib
|   |-- local
|   |   |-- bin
|   |   |-- include
|   |   |-- lib
|   |   |-- sbin
|   |   |-- share
|   |   `-- src
|   |-- sbin
|   |-- share
|   `-- src
`-- var
    |-- cache
    |-- lib
    |-- local
    |-- lock
    |-- log
    |-- opt
    |-- run
    |-- spool
    `-- tmp
</code></pre>
</div>
</details>
<h2 id="Создание-ряда-системных-файлов"><a class="header" href="#Создание-ряда-системных-файлов">Создание ряда системных файлов</a></h2>
<p>Обычно системы Linux хранят список смонтированных файловых систем в <code>/etc/mtab</code>. С учётом того, как устроена наша система, в качестве <code>/etc/mtab</code> в ней будет выступать ссылка на <code>/proc/mounts</code>:</p>
<pre><code class="language-bash">ln -svf ../proc/mounts $LFA_SYS/etc/mtab
</code></pre>
<p>Для того, чтобы пользователь <code>root</code> мог войти в систему и чтобы имя <code>root</code> было распознано, создайте в файлах <code>/etc/passwd</code> и <code>/etc/group</code> соответствующие записи:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/passwd &lt;&lt; &quot;EOF&quot;
root::0:0:root:/root:/bin/ash
EOF

cat &gt; $LFA_SYS/etc/group &lt;&lt; &quot;EOF&quot;
root:x:0:
EOF
</code></pre>
<p>Программы <code>login</code>, <code>agetty</code> и <code>init</code> используют файл <code>lastlog</code> для записи информации о том, кто и когда вошёл в систему. Однако они не будут ничего туда записывать, если этого файла нет. Создайте файл <code>lastlog</code> и дайте ему соответствующие разрешения:</p>
<pre><code class="language-bash">touch $LFA_SYS/var/log/lastlog
chmod -v 664 $LFA_SYS/var/log/lastlog
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libgcc"><a class="header" href="#libgcc">libgcc</a></h1>
<blockquote>
<p>При компиляции динамических библиотек с помощью GCC требуется, чтобы <code>libgcc</code> могла быть загружена во время выполнения программы. Поэтому нам нужно скопировать библиотеку <code>libgcc</code>, которая ранее была собрана для кросс-компилятора.</p>
<ul>
<li><strong>Версия:</strong> 13.2.0</li>
<li><strong>Домашняя страница:</strong> <a href="https://gcc.gnu.org">https://gcc.gnu.org</a></li>
<li><strong>Время сборки:</strong> 0 ОВС</li>
</ul>
</blockquote>
<h2 id="Установка-5"><a class="header" href="#Установка-5">Установка</a></h2>
<p>Скопируйте библиотеку в директорию собираемой ОС:</p>
<pre><code class="language-bash">cp $LFA_CROSS/lib64/libgcc_s.so.1 $LFA_SYS/lib
</code></pre>
<p>Удалите из установленной библиотеки лишние для вас отладочные символы:</p>
<pre><code class="language-bash">$STRIP $LFA_SYS/lib/libgcc_s.so.1
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="base/libgcc.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные библиотеки:</strong> <code>libgcc_s.so.1</code></li>
</ul>
<h3 id="Описание-компонентов-4"><a class="header" href="#Описание-компонентов-4">Описание компонентов</a></h3>
<ul>
<li><code>libgcc_s.so.1</code> - при компиляции динамически линкуемых программ с помощью GCC требуется, чтобы во время выполнения такой программы была загружена библиотека <code>libgcc_s.so.1</code> из состава GCC.</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="musl-1"><a class="header" href="#musl-1">musl</a></h1>
<blockquote>
<p>Минималистичная стандартная библиотека языка С.</p>
<ul>
<li><strong>Версия:</strong> 1.2.5</li>
<li><strong>Домашняя страница:</strong> <a href="https://musl.libc.org">https://musl.libc.org</a></li>
<li><strong>Время сборки:</strong> 1 ОВС</li>
</ul>
</blockquote>
<h2 id="Настройка-5"><a class="header" href="#Настройка-5">Настройка</a></h2>
<pre><code class="language-bash">./configure CROSS_COMPILE=$LFA_TGT- \
  --prefix=/ \
  --disable-static \
  --target=$LFA_TGT
</code></pre>
<h2 id="Сборка-4"><a class="header" href="#Сборка-4">Сборка</a></h2>
<pre><code class="language-bash">make
</code></pre>
<h2 id="Установка-6"><a class="header" href="#Установка-6">Установка</a></h2>
<pre><code class="language-bash">make DESTDIR=$LFA_SYS install-libs
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="base/musl.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>ld-musl</code></li>
<li><strong>Установленные библиотеки:</strong> <code>libc.so.0</code>, <code>libcrypt.so.0</code>, <code>libdl.so.0</code>, <code>libm.so.0</code>, <code>libpthread.so.0</code>, <code>librt.so.0</code></li>
</ul>
<h3 id="Описание-компонентов-5"><a class="header" href="#Описание-компонентов-5">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>ld-musl</code> - динамический компоновщик/загрузчик musl.</li>
</ul>
</li>
<li><strong>Библиотеки:</strong>
<ul>
<li><code>libc</code> - библиотека языка C.</li>
<li><code>libcrypt</code> - криптографическая библиотека.</li>
<li><code>libdl</code> - библиотека для динамического компоновщика/зарузчика.</li>
<li><code>libm</code> - математическая библиотека.</li>
<li><code>libpthread</code> - библиотека потоков POSIX.</li>
<li><code>librt</code> - библиотека часов и таймера.</li>
</ul>
</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="busybox"><a class="header" href="#busybox">busybox</a></h1>
<blockquote>
<p>Объединяет крошечные версии многих распространённых утилит UNIX в один небольшой двоичный файл (1-2 Мбайт). Он заменяет большинство утилит, которые обычно находятся в GNU Coreutils, GNU Findutils и т.д.</p>
<ul>
<li><strong>Версия:</strong> 1.36.1</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.busybox.net">https://www.busybox.net</a></li>
<li><strong>Время сборки:</strong> 1 ОВС</li>
</ul>
</blockquote>
<h2 id="Настройка-6"><a class="header" href="#Настройка-6">Настройка</a></h2>
<blockquote>
<p>Процесс настройки пакета <code>busybox</code> схож с процессом настройки ядра Linux. Параметры сборки записываются в файл <code>.config</code>. Можно сконфигурировать сборку в псевдографическом режиме (<code>make menuconfig</code>), а можно использовать стандартный конфиг (<code>make defconfig</code>). Вы можете сохранить файл <code>.config</code> для того, чтобы в будущем (в случае пересборки этой версии BusyBox или в случае сборки новой версии этого пакета) не конфигурировать пакет вновь.</p>
</blockquote>
<p>Убедитесь, что дерево исходного кода BusyBox чистое и не содержит лишних файлов:</p>
<pre><code class="language-bash">make mrproper
</code></pre>
<blockquote>
<p>Далее требуется настроить пакет BusyBox, выбрав те опции, которые вам нужны, и убрать то, что вам не требуется. В зависимости от числа выбранных опций зависит в том числе и размер вашей системы, однако BusyBox - вещь довольно минималистичная, и на размер системы влияет больше ядро Linux, его модули и файлы <a href="base/../additional/dtb.html">Device Tree</a>.</p>
</blockquote>
<pre><code class="language-bash">make ARCH=arm64 menuconfig
</code></pre>
<h3 id="Система-инициализации"><a class="header" href="#Система-инициализации">Система инициализации</a></h3>
<p>Поскольку чуть позже мы установим в LFA загрузочные скрипты, нам требуется система инициализации, которая эти скрипты будет исполнять. Для этого компилируйте BusyBox с поддержкой <code>init</code>, <code>halt</code>, <code>poweroff</code>, <code>reboot</code>. Кроме того, вам нужны программы <code>getty</code> и <code>login</code>.</p>
<pre><code>Init Utilities  ---&gt;
  &lt;*&gt; halt      [CONFIG_HALT]
  &lt;*&gt; poweroff  [CONFIG_POWEROFF]
  &lt;*&gt; reboot    [CONFIG_REBOOT]
  &lt;*&gt; init      [CONFIG_INIT]
Login/Password Management Utilities  ---&gt;
  &lt;*&gt; getty     [CONFIG_GETTY]
  &lt;*&gt; login     [CONFIG_LOGIN]
</code></pre>
<h3 id="Отключение-опций"><a class="header" href="#Отключение-опций">Отключение опций</a></h3>
<p>После конфигурирования вам нужно отлючить ряд возможностей, с которыми мы не смогли бы корректно собрать этот пакет.</p>
<p>Во-первых, отключите сборку <code>ifplugd</code> и <code>inetd</code>, поскольку их сборка вместе с <code>musl</code> имеет проблемы:</p>
<pre><code class="language-bash">sed -i 's/\(CONFIG_\)\(.*\)\(INETD\)\(.*\)=y/# \1\2\3\4 is not set/g' .config
sed -i 's/\(CONFIG_IFPLUGD\)=y/# \1 is not set/' .config
</code></pre>
<p>Отключите использование <code>utmp</code>/<code>wtmp</code>, поскольку <code>musl</code> их не поддерживает:</p>
<pre><code class="language-bash">sed -i 's/\(CONFIG_FEATURE_WTMP\)=y/# \1 is not set/' .config
sed -i 's/\(CONFIG_FEATURE_UTMP\)=y/# \1 is not set/' .config
</code></pre>
<p>Отключите использование <code>ipsvd</code> для TCP и UDP, поскольку у него есть проблемы сборки вместе с <code>musl</code> (аналогично <code>inetd</code>):</p>
<pre><code class="language-bash">sed -i 's/\(CONFIG_UDPSVD\)=y/# \1 is not set/' .config
sed -i 's/\(CONFIG_TCPSVD\)=y/# \1 is not set/' .config
</code></pre>
<p>Обычно в системах подобных LFA не требуются пакетные менеджеры типа того же <code>dpkg</code>. К тому же, в BusyBox предоставляется достаточно «обрезанная» версия dpkg с некоторыми ограничениями. Да и подобных LFS руководствах (в том числе и в LFA) не рекомендуется использовать подобные пакетные менеджеры во избежание проблем и поломок системы. Если вам не нужен <code>dpkg</code>, отключите его сборку, чем освободите около 73 Кб памяти:</p>
<pre><code class="language-bash">sed -i 's/\(CONFIG_DPKG\)=y/# \1 is not set/' .config
sed -i 's/\(CONFIG_DPKG_DEB\)=y/# \1 is not set/' .config
</code></pre>
<p>Тоже самое сделайте и с версией пакетного менеджера <code>rpm</code>:</p>
<pre><code class="language-bash">sed -i 's/\(CONFIG_RPM\)=y/# \1 is not set/' .config
sed -i 's/\(CONFIG_RPM2CPIO\)=y/# \1 is not set/' .config
</code></pre>
<h2 id="Сборка-5"><a class="header" href="#Сборка-5">Сборка</a></h2>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT-
</code></pre>
<h2 id="Установка-7"><a class="header" href="#Установка-7">Установка</a></h2>
<p>Установите пакет:</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT- \
  CONFIG_PREFIX=$LFA_SYS install
</code></pre>
<blockquote>
<p>Заметьте, что BusyBox содержит множество программ, но все они объединены в один файл. Однако для удобства (чтобы, например, вводить не <code>busybox mv file1 file2</code>, а просто <code>mv file1 file2</code> как в обычных системах) в каталогах <code>$LFA_SYS/bin</code> и <code>$LFA_SYS/sbin</code> создаются ссылки на <code>busybox</code> с именами программ, которые содержит этот пакет.</p>
</blockquote>
<p>Если вы собираетесь собирать ядро с помощью модулей, вам нужно убедиться, что <code>depmod.pl</code> доступен для выполнения на вашем хосте:</p>
<pre><code class="language-bash">cp -v examples/depmod.pl $LFA/tools/bin
chmod -v 755 $LFA/tools/bin/depmod.pl
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="base/busybox.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>[</code>, <code>[[</code>, <code>arch</code>, <code>ascii</code>, <code>ash</code>, <code>awk</code>, <code>base32</code>, <code>base64</code>, <code>basename</code>, <code>bc</code>, <code>bunzip2</code>, <code>busybox</code> и другие<sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<h3 id="Описание-компонентов-6"><a class="header" href="#Описание-компонентов-6">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>busybox</code> - реализация стандартных UNIX утилит.</li>
<li>все остальные - ссылки на <code>busybox</code>.</li>
</ul>
</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Набор установленного ПО зависит от того, какие настройки вы указывали при конфигурировании пакета.</p>
</div>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iana-etc"><a class="header" href="#iana-etc">iana-etc</a></h1>
<blockquote>
<p>Данные для сетевых служб и сервисов. Необходим для обеспечения надлежащих сетевых возможностей.</p>
<ul>
<li><strong>Версия:</strong> 20240125</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.iana.org/protocols">https://www.iana.org/protocols</a></li>
<li><strong>Время сборки:</strong> 0.01 ОВС</li>
</ul>
</blockquote>
<h2 id="Установка-8"><a class="header" href="#Установка-8">Установка</a></h2>
<p>Скопируйте файлы <code>services</code> и <code>protocols</code> в <code>$LFA_SYS/etc</code>:</p>
<pre><code class="language-bash">cp -v services protocols $LFA_SYS/etc
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="base/iana-etc.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные файлы:</strong> <code>/etc/protocols</code> и <code>/etc/services</code></li>
</ul>
<h3 id="Описание-компонентов-7"><a class="header" href="#Описание-компонентов-7">Описание компонентов</a></h3>
<ul>
<li><code>/etc/protocols</code> - описывает различные интернет-протоколы DARPA, которые доступны из подсистемы TCP/IP.</li>
<li><code>/etc/services</code> - обеспечивает сопоставление между дружественными текстовыми именами интернет-сервисов и соответствующими им номерами портов и типами протоколов.</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wireless-tools"><a class="header" href="#wireless-tools">wireless-tools</a></h1>
<blockquote>
<p>Набор инструментов для работы с Wireless Extensions (WE — API ядра Linux, позволяющий драйверу передавать в пользовательское пространство конфигурацию и статистику, характерные для беспроводных локальных сетей).</p>
<ul>
<li><strong>Версия:</strong> 29</li>
<li><strong>Домашняя страница:</strong> <a href="https://hewlettpackard.github.io/wireless-tools/">https://hewlettpackard.github.io/wireless-tools/</a></li>
<li><strong>Время сборки:</strong> 0.1 ОВС</li>
<li><strong>Необходимые патчи:</strong>
<ul>
<li><a href="https://www.linuxfromscratch.org/patches/blfs/svn/wireless_tools-29-fix_iwlist_scanning-1.patch">https://www.linuxfromscratch.org/patches/blfs/svn/wireless_tools-29-fix_iwlist_scanning-1.patch</a></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Настройка-ядра"><a class="header" href="#Настройка-ядра">Настройка ядра</a></h2>
<p>Чтобы использовать Wireless Tools, ядро должно иметь соответствующие драйверы и прочие компоненты. Когда вы будете собирать ядро, не забудьте включить следующие опции:</p>
<pre><code>[*] Networking support ---&gt;                            [NET]
  [*] Wireless ---&gt;                                    [WIRELESS]
    &lt;*/M&gt; cfg80211 - wireless configuration API        [CFG80211]
    [*]   cfg80211 wireless extensions compatibility   [CFG80211_WEXT]
</code></pre>
<h2 id="Настройка-7"><a class="header" href="#Настройка-7">Настройка</a></h2>
<p>Исправьте <code>Makefile</code>, чтобы можно было собрать пакет, используя наш кросс-компилятор:</p>
<pre><code class="language-bash">sed -i s/gcc/\$\{LFA\_TGT\}\-gcc/g Makefile
sed -i s/\ ar/\ \$\{LFA\_TGT\}\-ar/g Makefile
sed -i s/ranlib/\$\{LFA\_TGT\}\-ranlib/g Makefile
</code></pre>
<h2 id="Сборка-6"><a class="header" href="#Сборка-6">Сборка</a></h2>
<blockquote>
<p>Существуют опции, которые можно передать в <code>make</code> и <code>make install</code>, чтобы уменьшить размер и функциональность этого пакета. В файле <code>INSTALL</code> вы можете узнать дополнительную информацию об этом.</p>
</blockquote>
<pre><code class="language-bash">make PREFIX=$LFA_SYS
</code></pre>
<h2 id="Установка-9"><a class="header" href="#Установка-9">Установка</a></h2>
<pre><code class="language-bash">make install PREFIX=$LFA_SYS
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="base/wireless-tools.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные программы:</strong> <code>ifrename</code>, <code>iwconfig</code>, <code>iwevent</code>, <code>iwgetid</code>, <code>iwlist</code>, <code>iwpriv</code> и <code>iwspy</code></li>
<li><strong>Установленные библиотеки:</strong> <code>libiw.so</code></li>
</ul>
<h3 id="Описание-компонентов-8"><a class="header" href="#Описание-компонентов-8">Описание компонентов</a></h3>
<ul>
<li><strong>Программы:</strong>
<ul>
<li><code>ifrename</code> - переименовывает сетевые интерфейсы на основе различных статистичесих критериев.</li>
<li><code>iwconfig</code> - настраивает беспроводную сеть.</li>
<li><code>iwevent</code> - отображает события беспроводной сети, генерируемые драйверами и изменениями настроек.</li>
<li><code>iwgetid</code> - собщает ESSID, NWID или адрес точки доступа беспроводной сети.</li>
<li><code>iwlist</code> - получает подробную информацию о беспроводной сети.</li>
<li><code>iwpriv</code> - настраивает дополнительные (частные) параметры интерфейса беспроводной сети.</li>
<li><code>iwspy</code> - получает статистику беспроводной связи с определённого узла.</li>
</ul>
</li>
<li><strong>Библитеки:</strong>
<ul>
<li><code>libiw.so</code> - функции, необходимые для работы программ из этого пакета и API для других программ.</li>
</ul>
</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Настройка-базовой-системы"><a class="header" href="#Настройка-базовой-системы">Настройка базовой системы</a></h1>
<p>В данной главе пойдёт речь о настройке собранной системы. Большое значение здесь играет система инициализации, которая, хоть и предоставляет готовые сервисные файлы, предназначенные только для LFA и уже готовые к работе, тем не менее, <code>lfa_init</code> всё ещё нуждается в настройке.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-etcfstab"><a class="header" href="#Создание-etcfstab">Создание /etc/fstab</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Настройка-mdev"><a class="header" href="#Настройка-mdev">Настройка mdev</a></h1>
<p><code>mdev</code> (является частью проекта BusyBox) - это замена <code>udev</code> с другой базой правил.</p>
<p>Создайте файл <code>/etc/mdev.conf</code>:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/mdev.conf &lt;&lt; &quot;EOF&quot;
# /etc/mdev/conf

# Devices:
# Syntax: %s %d:%d %s
# devices user:group mode

# null does already exist; therefore ownership has to be changed with command
null    root:root 0666  @chmod 666 $MDEV
zero    root:root 0666
grsec   root:root 0660
full    root:root 0666

random  root:root 0666
urandom root:root 0444
hwrandom root:root 0660

# console does already exist; therefore ownership has to be changed with command
#console        root:tty 0600   @chmod 600 $MDEV &amp;&amp; mkdir -p vc &amp;&amp; ln -sf ../$MDEV vc/0
console root:tty 0600 @mkdir -pm 755 fd &amp;&amp; cd fd &amp;&amp; for x in 0 1 2 3 ; do ln -sf /proc/self/fd/$x $x; done

fd0     root:floppy 0660
kmem    root:root 0640
mem     root:root 0640
port    root:root 0640
ptmx    root:tty 0666

# ram.*
ram([0-9]*)     root:disk 0660 &gt;rd/%1
loop([0-9]+)    root:disk 0660 &gt;loop/%1
sd[a-z].*       root:disk 0660 */lib/mdev/usbdisk_link
hd[a-z][0-9]*   root:disk 0660 */lib/mdev/ide_links
md[0-9]         root:disk 0660

tty             root:tty 0666
tty[0-9]        root:root 0600
tty[0-9][0-9]   root:tty 0660
ttyS[0-9]*      root:tty 0660
pty.*           root:tty 0660
vcs[0-9]*       root:tty 0660
vcsa[0-9]*      root:tty 0660

ttyLTM[0-9]     root:dialout 0660 @ln -sf $MDEV modem
ttySHSF[0-9]    root:dialout 0660 @ln -sf $MDEV modem
slamr           root:dialout 0660 @ln -sf $MDEV slamr0
slusb           root:dialout 0660 @ln -sf $MDEV slusb0
fuse            root:root  0666

# dri device
card[0-9]       root:video 0660 =dri/

# alsa sound devices and audio stuff
pcm.*           root:audio 0660 =snd/
control.*       root:audio 0660 =snd/
midi.*          root:audio 0660 =snd/
seq             root:audio 0660 =snd/
timer           root:audio 0660 =snd/

adsp            root:audio 0660 &gt;sound/
audio           root:audio 0660 &gt;sound/
dsp             root:audio 0660 &gt;sound/
mixer           root:audio 0660 &gt;sound/
sequencer.*     root:audio 0660 &gt;sound/

# misc stuff
agpgart         root:root 0660  &gt;misc/
psaux           root:root 0660  &gt;misc/
rtc             root:root 0664  &gt;misc/

# input stuff
event[0-9]+     root:root 0640 =input/
mice            root:root 0640 =input/
mouse[0-9]      root:root 0640 =input/
ts[0-9]         root:root 0600 =input/

# v4l stuff
vbi[0-9]        root:video 0660 &gt;v4l/
video[0-9]      root:video 0660 &gt;v4l/

# dvb stuff
dvb.*           root:video 0660 */lib/mdev/dvbdev

# load drivers for usb devices
usbdev[0-9].[0-9]       root:root 0660 */lib/mdev/usbdev
usbdev[0-9].[0-9]_.*    root:root 0660

# net devices
tun[0-9]*       root:root 0600 =net/
tap[0-9]*       root:root 0600 =net/

# zaptel devices
zap(.*)         root:dialout 0660 =zap/%1
dahdi!(.*)      root:dialout 0660 =dahdi/%1

# raid controllers
cciss!(.*)      root:disk 0660 =cciss/%1
ida!(.*)        root:disk 0660 =ida/%1
rd!(.*)         root:disk 0660 =rd/%1

sr[0-9]         root:cdrom 0660 @ln -sf $MDEV cdrom 

# hpilo
hpilo!(.*)      root:root 0660 =hpilo/%1

# xen stuff
xvd[a-z]        root:root 0660 */lib/mdev/xvd_links
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-etcprofile"><a class="header" href="#Создание-etcprofile">Создание /etc/profile</a></h1>
<p>Файл <code>/etc/profile</code> содержит в себе общесистемные настройки командной оболочки. Создайте этот файл:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/profile &lt;&lt; &quot;EOF&quot;
# /etc/profile

# Set the initial path
export PATH=/bin:/usr/bin

if [ `id -u` -eq 0 ] ; then
        PATH=/bin:/sbin:/usr/bin:/usr/sbin
        unset HISTFILE
fi

# Setup some environment variables.
export USER=`id -un`
export LOGNAME=$USER
export HOSTNAME=`/bin/hostname`
export HISTSIZE=1000
export HISTFILESIZE=1000
export PAGER='/bin/more '
export EDITOR='/bin/ed'

# End /etc/profile
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Установка-имени-хоста"><a class="header" href="#Установка-имени-хоста">Установка имени хоста</a></h1>
<p>Во время загрузки <code>lfa_init</code> устанавливает имя хоста системы (hostname). Имя хоста содержится в файле <code>/etc/hostname</code>. Создайте его:</p>
<pre><code class="language-bash">echo &quot;[lfa]&quot; &gt; $LFA_SYS/etc/hostname
</code></pre>
<p>Замените <code>[lfa]</code> на имя, присвоенное компьютеру. Не вводите здесь полное доменное имя (FQDN). Эта информация будет помещена в файл <code>/etc/hosts</code> в следующем разделе.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Настройка-сети"><a class="header" href="#Настройка-сети">Настройка сети</a></h1>
<p>Создайте базовый <code>/etc/hosts</code> файл:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/hosts &lt;&lt; &quot;EOF&quot;
# Begin /etc/hosts

127.0.0.1 localhost
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-ядра"><a class="header" href="#Сборка-ядра">Сборка ядра</a></h1>
<p>Ядро Linux - основной компонент операционной системы, выступающий промежуточным звеном между оборудованием и программным обеспечением ОС.</p>
<h2 id="Общие-рекомендации-по-сборке-ядра"><a class="header" href="#Общие-рекомендации-по-сборке-ядра">Общие рекомендации по сборке ядра</a></h2>
<p>Первым делом нужно создать файл <code>.config</code>, содержащий параметры ядра. Для его создания можно воспользоваться следующими опциями:</p>
<ul>
<li><code>make defconfig</code> - создаёт стандартный конфиг с учётом архитектуры компьютера, для которого производится сборка.</li>
<li><code>make oldconfig</code> - задаёт пользователю ряд вопросов о конфигурации ядра в текстовом режиме. Не позволяет изменить уже заданные параметры (изменение возможно после путём редактирования файла <code>.config</code> вручную).</li>
<li><code>make menuconfig</code> - настройка ядра в псевдографическом меню. Доступно разделение всяческих функций, опций и драйверов по категориям, справка по этим вещам и прочее.</li>
</ul>
<p>После того, как вы настроили ядро, создав <code>.config</code> одним из способов, указанных ниже, рекомендуем вам сохранить созданный <code>.config</code> где-нибудь, чтобы использовать его в дальнейшем при возможных новых сборках ядра Linux.</p>
<p>Рекомендуем вам все ключевые компоненты ядра <em>встраивать</em> в ядро, а не компилировать в виде подключаемых <em>модулей</em>. Да и вообще рекомендуем вам оставить в конфигурации ядра (отмечено как <code>&lt;*&gt;</code> или <code>&lt;M&gt;</code><sup class="footnote-reference"><a href="#1">1</a></sup>) только то, что вам действительно необходимо. Это поможет вам сэкономить место на диске (размер одних только установленных в систему модулей легко может превысить объём всей системы без них) и упростить процесс загрузки системы (поскольку не придётся заботиться о том, какие модули загружать, а какие - нет).</p>
<p>В случае возникновения ошибки сборки, если рядом с этой ошибкой нет подробного текста о причине её возникновения, прочитайте весь вывод <code>make</code> - иногда сообщение о причине ошибки может быть очень далеко от последнего выведенного <code>make</code> сообщения. Это особенно актуально, если вы собираете ядро в несколько потоков.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>&lt;*&gt;</code> означает, что эта функция будет встроена в двоичный файл ядра, а <code>&lt;M&gt;</code> - что эта функция будет скомпилирована как модуль.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">linux</a></h1>
<blockquote>
<p>Ядро операционной системы.</p>
<ul>
<li><strong>Версия:</strong> 6.6.6</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.kernel.org">https://www.kernel.org</a></li>
<li><strong>Время сборки:</strong> 666 ОВС</li>
</ul>
</blockquote>
<p>Процесс сборки ядра состоит из нескольких процессов: конфигурирование, компиляция и установка. Прочитайте файл <code>README</code> в дереве исходного кода Linux, чтобы узнать об альтернативных методах, отличных от того, как конфигурируется ядро в этом руководстве.</p>
<h2 id="Подготовка-2"><a class="header" href="#Подготовка-2">Подготовка</a></h2>
<p>Убедитесь в том, что дерево исходного кода ядра не содержит лишних файлов:</p>
<pre><code class="language-bash">make mrproper
</code></pre>
<p>Разработчики ядра рекомендуют выполнять эту команду каждый раз, когда вы собираете Linux.</p>
<h2 id="Настройка-8"><a class="header" href="#Настройка-8">Настройка</a></h2>
<blockquote>
<p>Поскольку вы создаёте встраиваемую систему, убедитесь, что все <em>ключевые</em> компоненты <strong>встроены</strong> в ядро, а не являются модулями (в меню, которое откроется по команде далеее опция отмечена как <code>&lt;*&gt;</code>, а не как <code>&lt;M&gt;</code>). Ключевыми обычно являются опции для поддержки консоли, видео, дисков и файловых систем, а также сети. Без них система не будет функционировать должным образом. Рекомендуется конфигурировать ядро без модулей, чтобы сэкономить место на диске и упростить процесс загрузки системы.</p>
</blockquote>
<p>Откройте псевдографическое меню, в котором вам нужно выбрать все опции, которые нужны вам для корректной работы ядра на компьютере, для которого вы собираете систему:</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT- menuconfig
</code></pre>
<h3 id="Выбор-платформы"><a class="header" href="#Выбор-платформы">Выбор платформы</a></h3>
<p>Обязательно зайдите в раздел <code>Platform selection  ---&gt;</code> и отметьте там поддержку необходимых для вас SoC. Например, если я собираю систему для компьютера Orange Pi 3 LTS с Allwinner SoC, то в этом списке мне нужно отметить только</p>
<pre><code>Platform selection  ---&gt;
  [*] Allwinner sunxi 64-bit SoC Family
</code></pre>
<h3 id="fuse"><a class="header" href="#fuse">FUSE</a></h3>
<p>FUSE (англ. filesystem in userspace — «файловая система в пользовательском пространстве») — свободный модуль для ядер Unix-подобных операционных систем, позволяющий разработчикам создавать новые типы файловых систем, доступные для монтирования пользователями без привилегий (прежде всего — виртуальных файловых систем); это достигается за счёт запуска кода файловой системы в пользовательском пространстве, в то время как модуль FUSE предоставляет связующее звено для актуальных интерфейсов ядра. C использованием средств FUSE разработаны, в частности, SSHFS, NTFS-3G, GlusterFS, ZFS.</p>
<pre><code>File systems  ---&gt;
  &lt;*/M&gt; FUSE (Filesystem in Userspace) support [CONFIG_FUSE_FS]
</code></pre>
<h2 id="Сборка-7"><a class="header" href="#Сборка-7">Сборка</a></h2>
<p>Скомпилируйте ядро, используя только что созданный <code>.config</code>:</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT-
</code></pre>
<p>Теперь вам необходимо скомпилировать файлы devicetree:</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT- dtbs
</code></pre>
<h2 id="Установка-10"><a class="header" href="#Установка-10">Установка</a></h2>
<blockquote>
<p><strong>Следующие действия нужно выполнить, если вы собирали ядро с модулями:</strong></p>
<p>При использовании модулей ядра может потребоваться файл <code>/etc/modprobe.conf</code>. Информация, касающаяся модулей и конфигурации ядра, находится в документации в директории <code>Documentation/</code>. Также будет не лишним прочитать документацию (man) <code>modprobe.conf(5)</code>.</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT- \
  INSTALL_MOD_PATH=$LFA_SYS modules_install
</code></pre>
</blockquote>
<h3 id="Установка-ядра-и-ряда-дополнительных-файлов"><a class="header" href="#Установка-ядра-и-ряда-дополнительных-файлов">Установка ядра и ряда дополнительных файлов</a></h3>
<p>Конфигурационный файл <code>.config</code> содержит все настройки конфигурации только что собранного ядра. Было бы неплохим сохранить этот файл для дальнейшего пользования:</p>
<pre><code class="language-bash">cp -v .config $LFA_SYS/boot/config-6.6.6
</code></pre>
<p>Скопируйте файл <code>System.map</code> в <code>/boot</code>:</p>
<pre><code class="language-bash">cp -v System.map $LFA_SYS/boot/System.map-6.6.6
</code></pre>
<p>Полученное ядро будет находиться в директории <code>arch/arm64/boot</code>. Возможно, что там будет находиться несколько вариантов одного и того же ядра, просто с разным сжатием или добавлением помощников загрузчика. Следуйте инструкциям вашего загрузчика по копированию ядра в конечную систему. Например:</p>
<pre><code class="language-bash">cp -iv arch/arm64/boot/Image $LFA_SYS/boot/vmlinuz-6.6.6
</code></pre>
<p>Для того, чтобы не указывать в опциях ядра полное имя <code>vmlinuz-6.6.6</code> создайте символическую ссылку:</p>
<pre><code class="language-bash">ln -svf vmlinuz-6.6.6 $LFA_SYS/boot/vmlinuz
</code></pre>
<h3 id="Установка-файлов-devicetree"><a class="header" href="#Установка-файлов-devicetree">Установка файлов Devicetree</a></h3>
<p>Создайте в <code>$LFA_SYS/boot</code> директорию <code>dtb-6.6.6</code>:</p>
<pre><code class="language-bash">mkdir -pv $LFA_SYS/boot/dtb-6.6.6
</code></pre>
<p>И установите файлы Devicetree:</p>
<pre><code class="language-bash">make ARCH=arm64 CROSS_COMPILE=$LFA_TGT- \
  INSTALL_DTBS_PATH=$LFA_SYS/boot/dtb-6.6.6 dtbs_install
</code></pre>
<p>Для того, чтобы не указывать в <code>boot.cmd</code>, который мы скоро напишем, версию ядра, сделайте символическую ссылку:</p>
<pre><code class="language-bash">ln -svf dtb-6.6.6 $LFA_SYS/boot/dtb
</code></pre>
<p>Создание ссылок на ряд периодически изменяющихся файлов сделает проще их обновление до новой версии: нужно просто установить новую версию файла ядра и директории с devicetree в <code>$LFA_SYS/boot/</code> и обновить символические ссылки. Этим мы можем оставить предыдущие версии ядра и devicetree, которые могут понадобиться, если окажется, что их новые версии работают некорректно или не работают вовсе.</p>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="kernel/linux.html#admonition-Внимание"></a></p>
</div>
<div>
<p>В <code>$LFA_SYS/boot/dtb-6.6.6</code> будут установлены скомпилированные файлы devicetree только для тех плат, поддержку которых вы указали при конфигурировании ядра. В этой директории будут созданы поддиректории с именами используемых в этих платах SoC, например:</p>
<ul>
<li><code>$LFA_SYS/boot/dtb-6.6.6/allwinner/</code></li>
<li><code>$LFA_SYS/boot/dtb-6.6.6/broadcom/</code></li>
<li><code>$LFA_SYS/boot/dtb-6.6.6/rockchip/</code></li>
</ul>
<p>В этих поддиректориях будут содержаться файлы <code>*.dtb</code> для поддерживаемых плат. Если вам что-либо отсюда не нужно, то ради экономии места и уменьшения размера собранного дистрибутива вы можете удалить лишние файлы. Однако будьте готовы, что на каких-то компьютерах ваша система может не заработать.</p>
</div>
</div>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="kernel/linux.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные файлы:</strong> <code>.config-6.6.6</code>, <code>vmlinuz-6.6.6</code>, <code>vmlinuz</code>, <code>System.map-6.6.6</code>, <code>dtb-6.6.6/*</code>, <code>dtb/</code></li>
</ul>
<h3 id="Описание-компонентов-9"><a class="header" href="#Описание-компонентов-9">Описание компонентов</a></h3>
<ul>
<li><code>.config-6.6.6</code> - содержит параметры сборки ядра.</li>
<li><code>vmlinuz-6.6.6</code>, <code>vmlinuz</code> - скомпилированное ядро Linux.</li>
<li><code>System.map-6.6.6</code> - список адресов и символов; в нём указаны точки входа и адреса всех функций и структур данных в ядре. Иногда полезен при отладке.</li>
<li><code>dtb-6.6.6/</code>, <code>dtb/</code> - директория с файлами <a href="kernel/../additional/dtb.html">devicetree</a>.</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-загрузчика"><a class="header" href="#Сборка-загрузчика">Сборка загрузчика</a></h1>
<blockquote>
<p>Загрузчик операционной системы, предназначенный для встраиваемых систем на MIPS, ARM, PowerPC и т.д.</p>
<ul>
<li><strong>Версия:</strong> 2023.10</li>
<li><strong>Домашняя страница:</strong> <a href="https://source.denx.de/u-boot/u-boot">https://source.denx.de/u-boot/u-boot</a></li>
<li><strong>Время сборки:</strong> 10 ОВС</li>
</ul>
</blockquote>
<h2 id="Примерный-порядок-сборки"><a class="header" href="#Примерный-порядок-сборки">Примерный порядок сборки</a></h2>
<p>Для некоторых плат перед сборкой U-Boot необходимо собрать предварительные файлы. Например, для некоторых плат необходимо собрать ARM Trusted Firmware. Для получения более подробных сведений смотрите окументацию к поддерживаемых в LFA платах далее.</p>
<p>После чего требуется собрать U-Boot и записать полученный образ на карту памяти.</p>
<h2 id="Настройка-9"><a class="header" href="#Настройка-9">Настройка</a></h2>
<p>Директория <code>configs/</code> содержит шаблоны конфигурационных файлов для поддерживаемых [проектом U-Boot, а не LFA] плат в соответствии со следующей схемой наименования:</p>
<pre><code>&lt;имя платы&gt;_defconfig
</code></pre>
<p>Эти файлы лишены настроек по умолчанию. Поэтому вы не можете использовать их напрямую. Вместо этого их имя служит в качестве цели <code>make</code> для генерации фактического конфигурационного файла <code>.config</code>. Например, шаблон конфигурации для платы Odroid C2 называется <code>odroid-c2_defconfig</code>. Соответствующий файл <code>.config</code> генерируется командой:</p>
<pre><code class="language-bash">make odroid-c2_defconfig
</code></pre>
<blockquote>
<p><strong>Для плат на базе SoC Allwinner:</strong></p>
<p>На вики <a href="https://linux-sunxi.org/"><strong>linux-sunxi</strong></a> также можно найти имя <code>defconfig</code> файла на соответствующей странице платы.</p>
</blockquote>
<p>Вы можете сконфигурировать пакет командой:</p>
<pre><code class="language-bash">make menuconfig
</code></pre>
<h2 id="Сборка-8"><a class="header" href="#Сборка-8">Сборка</a></h2>
<blockquote>
<p>Для сборки вам по прежгнему нужен наш кросс-компилятор. Кроме того, в системе должны быть установлены пакеты <code>swig</code> и <code>python-setuptools</code>.</p>
</blockquote>
<pre><code class="language-bash">CROSS_COMPILE=$LFA_TGT- make
</code></pre>
<h3 id="Компилятор-devicetree"><a class="header" href="#Компилятор-devicetree">Компилятор Devicetree</a></h3>
<p>Платам, использующим <code>CONFIG_OF_CONTROL</code> (т.е. почти всем), нужен компилятор <a href="bootloader/../additional/dtb.html">Devicetree</a> (<code>dtc</code>). Платам с <code>CONFIG_PYLIBFDT</code> требуется <code>pylibfdt</code> (библиотека Python для доступа к данным Devicetree). Подходящие версии этих библиотек включены в дерево U-Boot в директории <code>scripts/dtc</code> и собираются автоматически по мере необходимости.</p>
<p>Если вы хотите использовать их системные версии, используйте переменную <code>DTC</code>, в которой будет указан путь до <code>dtc</code>:</p>
<pre><code class="language-bash">CROSS_COMPILE=$LFA_TGT- DTC=/usr/bin/dtc make
</code></pre>
<p>В этом случае <code>dtc</code> и <code>pylibfdt</code> не будут собраны. Система сборки проверит, что версия <code>dtc</code> достаточно новая. Она также убедится, что <code>pylibfdt</code> присутствует, если это необходимо.</p>
<p>Обратите внимание, что инструменты <a href="https://docs.u-boot.org/en/latest/build/tools.html"><strong>Host Tools</strong></a> всегда собираются с включенной версией <code>libfdt</code>, поэтому в настоящее время невозможно собрать U-Boot с системной <code>libfdt</code>.</p>
<h3 id="lto"><a class="header" href="#lto">LTO</a></h3>
<p>U-Boot поддерживает link-time optimisation, которая может уменьшить размер скомпилированных двоичных файлов, особенно при использовании SPL.</p>
<p>В настоящее время эта функция может быть включена на платах ARM путём добавления <code>CONFIG_LTO=y</code> в файл <code>defconfig</code>.</p>
<p>Однако в таком случае загрузчик будет собираться несколько медленнее, чем без LTO.</p>
<h2 id="Установка-11"><a class="header" href="#Установка-11">Установка</a></h2>
<p>Процесс установки U-Boot специфичен для каждого компьютера. На данный момент в руководстве поддерживаются компьютеры на базе SoC <a href="bootloader/allwinner.html">Allwinner</a>, <a href="bootloader/broadcom.html">Broadcom</a> и <a href="bootloader/rockchip.html">Rockchip</a>, а также установка U-Boot для эмуляции в <a href="bootloader/qemu.html">QEMU</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allwinner"><a class="header" href="#allwinner">Allwinner</a></h1>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="bootloader/allwinner.html#admonition-Внимание"></a></p>
</div>
<div>
<p>В данной части предоставлены <em>общие</em> инструкции, которые приведут к сборке работающего загрузчика U-Boot, пригодного для дальнейшего использования. Конечно, «кастомная» сборка U-Boot и ряда дополнительных компонентов с другими параметрами допускается, но на данный момент я не предоставляю иных инструкций кроме этих. Возможно, что в будущем я добавлю ряд советов по изменению параметров сборки, но сейчас у меня на это нет ни времени, ни сил, ни желания.</p>
</div>
</div>
<h2 id="Сборка-образа-u-boot"><a class="header" href="#Сборка-образа-u-boot">Сборка образа U-Boot</a></h2>
<p>Распакуйте архив с исходниками загрузчика и перейдите в распакованную директорию, если не сделали этого ранее.</p>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="bootloader/allwinner.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Предполагается, что у вас уже установлена переменная окружения <code>BL31</code>.</p>
</div>
</div>
<h3 id="Настройка-10"><a class="header" href="#Настройка-10">Настройка</a></h3>
<blockquote>
<p>Подробные сведения о процессе настройки см. на <a href="bootloader/index.html#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0">предыдущей</a> странице. В частности, оттуда вам понадобятся сведения о том, какое значение подставлять в команду <code>make &lt;имя платы&gt;_defconfig</code> вместо <code>&lt;имя платы&gt;</code>.</p>
</blockquote>
<pre><code class="language-bash">make &lt;имя платы&gt;_defconfig
</code></pre>
<h3 id="Сборка-9"><a class="header" href="#Сборка-9">Сборка</a></h3>
<pre><code class="language-bash">make CROSS_COMPILE=$LFA_TGT-
</code></pre>
<p>Файл, содержащий всё необходимое, называется <code>u-boot-sunxi-with-spl.bin</code> и находится в корневой папке дерева исходного кода U-Boot. За исключением необработанных NAND-устройств его можно использовать для любого источника загрузки. Devicetree платы также включено.</p>
<h2 id="Сохранение-образа-u-boot"><a class="header" href="#Сохранение-образа-u-boot">Сохранение образа U-Boot</a></h2>
<p>Теперь рекомендуем вам сохранить образ U-Boot в другое место, чтобы в последующих главах можно было иметь к нему доступ для выполнения дальнейших действий:</p>
<pre><code class="language-bash">cp -v u-boot-sunxi-with-spl.bin $LFA/bootloader.bin
</code></pre>
<p>Этой командой вы скопируете образ в директорию <code>$LFA</code> под новым именем <code>bootloader.bin</code>.</p>
<hr />
<h2 id="Установка-u-boot"><a class="header" href="#Установка-u-boot">Установка U-Boot</a></h2>
<div id="admonition-under-construction" class="admonition admonish-bug">
<div class="admonition-title">
<p>Under construction!</p>
<p><a class="admonition-anchor-link" href="bootloader/allwinner.html#admonition-under-construction"></a></p>
</div>
<div>
<p>Инструкции ниже я перепечатал из <a href="https://docs.u-boot.org/en/latest/board/allwinner/sunxi.html#installing-u-boot"><strong>документации</strong></a> загрузчика и не уверен, что они применимы в нашем случае. Если вы знаете, как правильно устанавливать загрузчик ОС на определённый носитель информации, с которого будет происходить загрузки собранной системы LFA (MicroSD или eMMC), то, пожалуйста, свяжитесь со мной одним из следующих способов:</p>
<ul>
<li><a href="https://github.com/Linux-for-ARM/handbook/issues/new">Создайте issue в репозитории руководства</a>, где опишете шаги по сборке и установке загрузчика;</li>
<li><a href="https://t.me/brezhnev_zhiv">Напишите мне в личку в Telegram</a></li>
<li><a href="https://t.me/lfa_chat">Напишите в Telegram-чат руководства</a></li>
</ul>
<p>Меня интересует следующее: в <code>img</code>-образах существующих дистрибутивов (Debian, Ubuntu, Manjaro ARM, Armbian) уже существуют какие-то файлы загрузчика (если я правильно понимаю). Но я не понимаю того, как скомпилированный образ U-Boot (<code>u-boot-sunxi-with-spl.bin</code>) &quot;засунуть&quot; в <code>img</code>-образ системы, чтобы после его записи на SD-карту или eMMC с помощью <code>dd</code> я мог бы загрузить свою систему.</p>
<p>На всякий случай: меня в первую очередь интересует сборка U-Boot для Orange Pi (например, для Orange Pi 3 LTS), поскольку сейчас я располагаю именно этим компьютером.</p>
</div>
</div>
<h3 id="Установка-на-microsd-карту"><a class="header" href="#Установка-на-microsd-карту">Установка на MicroSD-карту</a></h3>
<p>Все SoC Allwinner пытаются найти загрузочный образ в 16 секторе (8 КБ) карты, подключенной к первому MMC-контроллеру. Чтобы перенести скомпилированный ранее образ на SD-карту с любого устройства (как с того, на котором выполнялась сборка, так и с сам<em>о</em>й платы), оснащённого устройством чтения MicroSD-карт, введите от имени пользователя <code>root</code>:</p>
<pre><code class="language-bash">dd if=boot-sunxi-with-spl.bin of=/dev/sdX bs=1k seek=8
</code></pre>
<p>где <code>X</code> — буква (<code>a</code>, <code>b</code>, <code>c</code>) устройства, например, <code>/dev/sdc</code>. Обратите внимание на то, что в некоторых случаях вместо <code>sdX</code> имя устройства может быть <code>mmcblkX</code>.</p>
<p>Новые SoC (начиная с 2014 г. и включая все ARM64 SoC) также ищут подпись в секторе 256 (128 КБ). Преимущество установки туда загрузчика в том, что он не пересекается с таблицей разделов GPT. Просто замените <code>seek=8</code> на <code>seek=128</code>.</p>
<hr />
<blockquote>
<p><strong>Смотрите также:</strong></p>
<p><a href="https://linux-sunxi.org/U-Boot"><strong>Страница U-Boot на linux-sunxi WiKi</strong></a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allwinner-Сборка-tf-a"><a class="header" href="#allwinner-Сборка-tf-a">Allwinner: Сборка TF-A</a></h1>
<blockquote>
<p>Проект Trusted Firmware-A предоставляет эталонную реализацию безопасного программного обеспечения для процессоров класса ARMv7-A и ARMv8-A.</p>
<ul>
<li><strong>Версия:</strong> 2.10.2</li>
<li><strong>Домашняя страница:</strong> <a href="https://www.trustedfirmware.org/projects/tf-a/">https://www.trustedfirmware.org/projects/tf-a/</a></li>
<li><strong>Время сборки:</strong> 1 ОВС</li>
</ul>
</blockquote>
<h2 id="Настройка-11"><a class="header" href="#Настройка-11">Настройка</a></h2>
<p>Вам нужно объявить переменную окружения <code>PLAT</code>, которая будет содержать имя целевой платформы для сборки:</p>
<pre><code class="language-bash">export PLAT=&quot;целевая платформа&quot;
</code></pre>
<blockquote>
<p><strong>Целевые платформы для сборки:</strong></p>
<p>Сборка TF-A специфична для каждого SoC, в частности, специфично значение переменной <code>PLAT</code>, которая передаётся системе сборки <code>make</code>. Вы можете воспользоваться значениями из таблицы ниже:</p>
<div class="table-wrapper"><table><thead><tr><th>SoC</th><th>Платформа</th></tr></thead><tbody>
<tr><td>Allwinner A64</td><td><code>sun50i_a64</code></td></tr>
<tr><td>Allwinner H5</td><td><code>sun50i_a64</code></td></tr>
<tr><td>Allwinner H6</td><td><code>sun50i_h6</code></td></tr>
<tr><td>Allwinner H616</td><td><code>sun50i_h616</code></td></tr>
<tr><td>Allwinner H313</td><td><code>sun50i_h616</code></td></tr>
<tr><td>Allwinner T507</td><td><code>sun50i_h616</code></td></tr>
<tr><td>Allwinner R329</td><td><code>sun50i_r329</code></td></tr>
</tbody></table>
</div>
<p>Для поиска всех целевых платформ введите:</p>
<pre><code class="language-bash">find plat/allwinner -name platform.mk
</code></pre>
<p>В файле <a href="https://trustedfirmware-a.readthedocs.io/en/latest/plat/allwinner.html"><code>docs/plat/allwinner.rst</code></a> содержится дополнительная информация и приведены некоторые опции сборки.</p>
</blockquote>
<p>Например, если в моей плате используется SoC Allwinner H6, то значение переменной <code>PLAT</code> будет равно <code>sun50i_h6</code>:</p>
<pre><code class="language-bash">export PLAT=&quot;sun50i_h6&quot;
</code></pre>
<h2 id="Сборка-10"><a class="header" href="#Сборка-10">Сборка</a></h2>
<pre><code class="language-bash">make CROSS_COMPILE=$LFA_TGT- DEBUG=1
</code></pre>
<h2 id="Настройка-окружения-1"><a class="header" href="#Настройка-окружения-1">Настройка окружения</a></h2>
<p>Теперь вам нужно объявить переменную окружения <code>BL31</code>, содержащую путь до скомпилированной микропрограммы:</p>
<pre><code class="language-bash">export BL31=$PWD/build/$PLAT/debug/bl31.bin
</code></pre>
<p>Необходимости в переменной <code>PLAT</code> больше нет, поэтому можете её удалить:</p>
<pre><code class="language-bash">unset PLAT
</code></pre>
<details id="admonition-Содержимое-пакета" class="admonition admonish-note">
<summary class="admonition-title">
<p>Содержимое пакета</p>
<p><a class="admonition-anchor-link" href="bootloader/allwinner-tf-a.html#admonition-Содержимое-пакета"></a></p>
</summary>
<div>
<ul>
<li><strong>Установленные файлы:</strong> <code>$PWD/build/$PLAT/debug/bl31.bin</code></li>
</ul>
<h3 id="Описание-компонентов-10"><a class="header" href="#Описание-компонентов-10">Описание компонентов</a></h3>
<ul>
<li><code>$PWD/build/$PLAT/debug/bl31.bin</code> - требуемый для сборки U-Boot компонент TF-A.</li>
</ul>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allwinner-Установка-кросс-компилятора-or2k"><a class="header" href="#allwinner-Установка-кросс-компилятора-or2k">Allwinner: Установка кросс-компилятора or2k</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allwinner-Сборка-scp-crust"><a class="header" href="#allwinner-Сборка-scp-crust">Allwinner: Сборка SCP (crust)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allwinner-Сборка-u-boot"><a class="header" href="#allwinner-Сборка-u-boot">Allwinner: Сборка U-Boot</a></h1>
<blockquote>
<p>Загрузчик операционной системы, предназначенный для встраиваемых систем на MIPS, ARM, PowerPC и т.д.</p>
<ul>
<li><strong>Версия:</strong> 2023.10</li>
<li><strong>Домашняя страница:</strong> <a href="https://source.denx.de/u-boot/u-boot">https://source.denx.de/u-boot/u-boot</a></li>
<li><strong>Время сборки:</strong> 10 ОВС</li>
</ul>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="bootloader/allwinner-uboot.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Предполагается, что у вас уже установлены нужные переменные окружения, в частности <code>BL31</code> и, опционально, <code>SCP</code>.</p>
</div>
</div>
<h3 id="Настройка-12"><a class="header" href="#Настройка-12">Настройка</a></h3>
<p>Директория <code>configs/</code> содержит шаблоны конфигурационных файлов для поддерживаемых [проектом U-Boot, а не LFA] плат в соответствии со следующей схемой наименования:</p>
<pre><code class="language-bash">&lt;имя платы&gt;_defconfig
</code></pre>
<p>Вы можете использовать имя одного из этих файлов в качестве цели <code>make</code> для генерации конфигурационного файла <code>.config</code>. Например, шаблон конфигурации для платы Odroid C2 называется <code>odroid-c2_defconfig</code>. Соответственно, файл <code>.config</code> генерируется командой:</p>
<pre><code class="language-bash">make odroid-c2_defconfig
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="broadcom"><a class="header" href="#broadcom">Broadcom</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rockchip"><a class="header" href="#rockchip">Rockchip</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Эмуляция-в-qemu-arm"><a class="header" href="#Эмуляция-в-qemu-arm">Эмуляция в QEMU (ARM)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-прочих-загрузочных-файлов"><a class="header" href="#Создание-прочих-загрузочных-файлов">Создание прочих загрузочных файлов</a></h1>
<p>Теперь нужно закончить создание ряда файлов, которые используются, в первую очередь, при загрузке дистрибутива.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Загрузочные-скрипты"><a class="header" href="#Загрузочные-скрипты">Загрузочные скрипты</a></h1>
<h2 id="inittab"><a class="header" href="#inittab">inittab</a></h2>
<p>Для начала создайте файл <code>/etc/inittab</code>, отвечающий за такие вещи как зарузка системы, её выключение и обработки поведения при нажатии комбинации <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd>.</p>
<pre><code class="language-bash">cat &gt;&gt; $LFA_SYS/etc/inittab &lt;&lt; &quot;EOF&quot;
::sysinit:/etc/rc.d/rc.S
::respawn:-/bin/sh -l
::ctrlaltdel:/sbin/reboot 
::shutdown:/etc/rc.d/rc.0
EOF
</code></pre>
<h2 id="Скрипты"><a class="header" href="#Скрипты">Скрипты</a></h2>
<p>Создайте директорию со скриптами:</p>
<pre><code class="language-bash">mkdir -pv $LFA_SYS/etc/rc.d
</code></pre>
<p>Скрипт <code>$LFA_SYS/etc/rc.d/rc.0</code> размонтирует диски при выключении системы:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/rc.d/rc.0 &lt;&lt; &quot;EOF&quot;
#!/bin/ash

sync
/sbin/umount -a -r &gt; /dev/null 2&gt;&amp;1
EOF
</code></pre>
<p>Скрипт <code>$LFA_SYS/etc/rc.d/rc.S</code> выполняется при загрузке:</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/etc/rc.d/rc.S &lt;&lt; &quot;EOF&quot;
#!/bin/ash

export PATH=/bin:/sbin

mount -v proc /proc -t proc

mkdir -pv /dev/pts
mount -vt devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts

# Временные файлы лучше держать в ОЗУ, чтобы снизить число операций
# чтения/записи на SD/eMMC накопителе
mount -vt tmpfs none -o nodev,nosuid,noatime /tmp
mount -vt tmpfs none -o nodev,nosuid,noatime /var/log
mount -vt tmpfs none -o nodev,nosuid,noatime /var/run
mount -vt tmpfs none -o nodev,nosuid,noatime /run

mount -v sysfs /sys -t sysfs

# Запускаем системный логгер и логгер ядра
syslogd
sleep 1
klogd -c 3

echo &quot;Press &lt;Enter&gt;...&quot;
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-uinitrd"><a class="header" href="#Создание-uinitrd">Создание uInitrd</a></h1>
<p>Загрузчик U-Boot требует наличие образа <code>uImage</code>. Сначала создайте директорию, в которой будет ряд файлов из собранной системы (<code>$LFA_SYS</code>):</p>
<pre><code class="language-bash">cd $LFA

mkdir LFA-uImage
cd LFA-uImage

cp -rv $LFA_SYS/{bin,dev,etc,lib,proc,root,sbin,srv,sys,tmp,var} .
find . | cpio -H newc -ov --owner root:root &gt; ../initramfs.cpio

cd ..
gzip initramfs.cpio
</code></pre>
<p>Создайте образ <code>uImage</code> с помощью программы <code>mkimage</code>:</p>
<pre><code class="language-bash">mkimage -A arm64 -T ramdisk -n uInitrd -d initramfs.cpio.gz uImage
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Создание-bootscr"><a class="header" href="#Создание-bootscr">Создание boot.scr</a></h1>
<p><code>boot.scr</code> — это загрузочный скрипт системы, предназначенный для U-Boot.</p>
<pre><code class="language-bash">cat &gt; $LFA_SYS/boot/boot.cmd &lt;&lt; &quot;EOF&quot;
setenv load_addr &quot;0x45000000&quot;
setenv rootdev &quot;/dev/mmcblk0p1&quot;
setenv rootfstype &quot;ext4&quot;

if test &quot;${devtype}&quot; = &quot;mmc&quot;; then part uuid mmc 0:1 partuuid; fi

setenv bootargs &quot;root=${rootdev} rootwait rootfstype=${rootfstype} ubootpart=${partuuid}&quot;

load ${devtype} ${devnum} ${ramdisk_addr_r} ${prefix}uImage
load ${devtype} ${devnum} ${load_addr} ${prefix}/dtb-6.6.6/allwinner/sun50i-h6-orangepi-3.dtb
load ${devtype} ${devnum} ${kernel_addr_r} ${prefix}vmlinuz-6.6.6

bootz ${kernel_addr} ${initrd_addr}:${filesize} ${script_addr}
EOF
</code></pre>
<p>Скомпилируйте этот файл:</p>
<pre><code class="language-bash">mkimage -C none -A arm -T script -d $LFA_SYS/boot/boot.cmd $LFA_SYS/boot/boot.scr
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-образа"><a class="header" href="#Сборка-образа">Сборка образа</a></h1>
<p>Всё готово для сборки <code>img</code>-образа, который в будущем будет пригоден для записи на SD-карту или eMMC-накопитель.</p>
<h2 id="Создание-базовых-файлов"><a class="header" href="#Создание-базовых-файлов">Создание базовых файлов</a></h2>
<p>Сначала создадим заголовок размером 2 Мб:</p>
<pre><code class="language-bash">dd if=/dev/zero bs=1M count=2 of=bootloader.img
</code></pre>
<p>И копируем сохранённый образ U-Boot по смещению 128:</p>
<pre><code class="language-bash">dd if=$LFA/bootloader.bin \
  conv=notrunc seek=128 \
  of=bootloader.img
</code></pre>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="create-img.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Вне зависимости от SoC (Allwinner, Broadcom или Rockchip), для которого вы собирали U-Boot, он был сохранён в файл <code>$LFA/bootloader.bin</code>. Так что имя файла в аргументе <code>dd if=...</code> правильное.</p>
</div>
</div>
<p>Теперь нужно создать образ, в котором будут содержаться файлы собранной системы:</p>
<pre><code class="language-bash">dd if=/dev/zero bs=1M count=512 of=rootfs.img
</code></pre>
<p>Здесь я установил размер образа в 512 Мб, но вы можете установить и свой.</p>
<p>Создайте файловую систему на этом разделе:</p>
<pre><code class="language-bash">mkfs.ext4 -L BOOT \
  -O ^metadata_csum -F \
  -b 4096 \
  -E stride=2,stripe-width=1024 \
  -L rootfs rootfs.img
</code></pre>
<h2 id="Копирование-файлов"><a class="header" href="#Копирование-файлов">Копирование файлов</a></h2>
<p>Смонтируйте полученный образ и скопируйте в неё файлы нашей системы (саму систему, ядро, Devicetree и сценарий загрузки):</p>
<pre><code class="language-bash">mkdir -pv /tmp/lfa_rootfs
sudo mount -v rootfs.img /tmp/lfa_rootfs

sudo cp -rfv $LFA_SYS/* /tmp/lfa_rootfs
sync
</code></pre>
<div id="admonition-Внимание-1" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="create-img.html#admonition-Внимание-1"></a></p>
</div>
<div>
<p>Все действия здесь выполняются от имени пользователя <code>lfa</code>. Поскольку здесь используется программа <code>sudo</code>, вам нужно добавить пользователя <code>lfa</code> в группу <code>wheel</code>.</p>
</div>
</div>
<p>После копирования файлов размонтируйте образ:</p>
<pre><code class="language-bash">sudo umount /tmp/lfa_rootfs
</code></pre>
<h2 id="Создание-окончательного-образа"><a class="header" href="#Создание-окончательного-образа">Создание окончательного образа</a></h2>
<p>Объедините два образа в один:</p>
<pre><code class="language-bash">dd if=rootfs.img conv=notrunc oflag=append bs=1M seek=2 of=bootloader.img
</code></pre>
<h2 id="Создание-таблицы-разделов"><a class="header" href="#Создание-таблицы-разделов">Создание таблицы разделов</a></h2>
<p>Созданный нами образ нерабочий, поскольку ещё не содержит таблицу разделов. Создайте её с помощью <code>fdisk</code>:</p>
<pre><code class="language-fdisk">fdisk bootloader.img
o
n
p
1
4096
+512M

w
</code></pre>
<blockquote>
<p><strong>Значения новых команд:</strong></p>
<p>После начала редактирования мы вводим команду <code>o</code>, чтобы создать пустую таблицу разделов MBR. Затем командой <code>n</code> создаём новый раздел. Выбираем тип, номер и первый сектор. Дело в том, что размер сектора равен 512 байт, т.е. 1 Кб равен двум секторам. Размер заголовка 2 Мб, т.е. 2048 Кб или 4096 секоторов. Размер раздела можно указать в Мб. Сохранение и выход командой <code>w</code>.</p>
</blockquote>
<p>Переименуйте файл <code>bootloader.img</code>, дав ему более логичное и подходящее имя:</p>
<pre><code class="language-bash">mv -v bootloader.img lfa-1.0.img
</code></pre>
<h2 id="Сжатие-образа"><a class="header" href="#Сжатие-образа">Сжатие образа</a></h2>
<p>При необходимости вы можете сжать образ с помощью <code>xz</code> или любого другого архиватора, который вам больше нравится. Я часто видел <code>img</code>-образы, сжатые с помощью <code>xz</code>, поэтому использую его:</p>
<pre><code class="language-bash">xz lfa-1.0.img
</code></pre>
<h2 id="Запись-образа-на-sd-карту"><a class="header" href="#Запись-образа-на-sd-карту">Запись образа на SD-карту</a></h2>
<p>Теперь вы можете записать полученный образ на SD-карту. Для этого можете использовать <code>dd</code>:</p>
<pre><code class="language-bash">sudo dd if=lfa-1.0.img of=/dev/sdX
</code></pre>
<p>где <code>X</code> - буква (<code>a</code>, <code>b</code>, <code>c</code>, etc.) устройства, на которое будет производиться запись образа, например, <code>/dev/sdc</code>. Обратите внимание на то, что в некоторых случаях вместо <code>sdX</code> имя устройства может быть и <code>mmcblkX</code>.</p>
<p>Также для записи можете использовать программу Balena Etcher.</p>
<hr />
<blockquote>
<p><strong>Смотрите также:</strong></p>
<ul>
<li><a href="https://docs.armbian.com/User-Guide_Getting-Started/#how-to-prepare-a-sd-card">How to prepare a SD card?</a></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-далее"><a class="header" href="#Что-далее">Что далее?</a></h1>
<p>После того, как вы собрали систему, вы можете обратиться к руководству <a href="https://linuxfromscratch.org/blfs/view/stable">BLFS</a>, в котором предоставлена информация о сборке дополнительного ПО. Несмотря на то, что оно не совсем совместимо с LFA (вам придётся оптимизировать команды для сборки оттуда для использования кросс-компилятора LFA), данные оттуда вам всё-таки смогут пригодиться.</p>
<p>Не забывайте посещать наш <a href="https://t.me/LinuxForARM">канал в Telegram</a>, чтобы быть в курсе последних изменений в LFA, а также <a href="https://t.me/lfa_chat">Telegram-чат</a> если у вас возникли вопросы или ошибки, либо если вам требуется обратная связь с разработчиком LFA.</p>
<p>Можете посетить проект <a href="https://tldp.org">The Linux Documentation Project</a>, содержащий большое число man-страниц, всевозможных HOWTO и прочую документацию.</p>
<p>Рекомендуем также посетить следующие сайты:</p>
<ul>
<li><a href="https://habr.com/ru/articles/470519/">Опыт создания сборок Linux под одноплатники с поддержкой обновлений</a>;</li>
<li><a href="https://habr.com/ru/articles/309618/">Немного о ARM Security Extensions (aka ARM TrustZone)</a>;</li>
<li><a href="https://habr.com/ru/articles/775488/">[Сборка системы для Orange Pi 5] Orange Pi 5 (как настоящий...)</a>;</li>
<li><a href="https://habr.com/ru/articles/763996/">Сборка прошивки из исходников для Orange PI i96(Orange PI 2g-iot)</a>;</li>
<li><a href="https://docs.u-boot.org/en/latest/index.html">Документация загрузчика U-Boot</a>;</li>
<li><a href="https://linuxfromscratch.org/hints/">LFS Hints</a></li>
</ul>
<hr />
<details>
  <summary><b>Ну и конечно же вы можете отблагодарить автора за проделанную работу...</b></summary>
  <p>... отправив ему донат на карту:</p>
  <blockquote><div align="center"><p>2202 2062 5233 5406 (Сбербанк)</p></div></blockquote>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вспомогательные-материалы"><a class="header" href="#Вспомогательные-материалы">Вспомогательные материалы</a></h1>
<p>Это необязательная часть, служащая дополнительным источником знаний. В некоторых случаях здесь могут быть приведены решения часто возникающих проблем и важные заметки по процессу сборки LFA.</p>
<p>В задачи этого раздела входит аккумулирование сведений как о процессе сборки своих систем, использующих ядро Linux, так и об ARM-компьютеров, для которых это руководство и предназначено.</p>
<p>От версии к версии этот раздел дополняется и актуализируется.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Процессоры-arm"><a class="header" href="#Процессоры-arm">Процессоры ARM</a></h1>
<p>ARM - семейство описаний и готовых топологий 32- и 64-битных микропроцессоров. К значимым семействам процессоров относятся ARM7, ARM9, ARM11 и Cortex. ARM-процессоры имеют низкое электропотребление, поэтому часто используются во встаиваемых системах и мобильных устройствах.</p>
<h3 id="arm7-60-72-МГц"><a class="header" href="#arm7-60-72-МГц">ARM7 (60-72 МГц)</a></h3>
<p>Процессоры на этой архитектуре предназначены для мобильных телефонов и встраиваемых систем. Сейчас активно вытесняется семейством Cortex.</p>
<h3 id="arm9-arm11-до-1-ГГц"><a class="header" href="#arm9-arm11-до-1-ГГц">ARM9, ARM11 (до 1 ГГц)</a></h3>
<p>Предназначено для мобильных устройств, КПК и встраиваемых систем высокой производительности.</p>
<h3 id="cortex-a"><a class="header" href="#cortex-a">Cortex-A</a></h3>
<p>Пришли на смену ARM9 и ARM11.</p>
<h3 id="cortex-m"><a class="header" href="#cortex-m">Cortex-M</a></h3>
<p>Пришли на смену ARM7. Предназначены для встраиваемых систем низкой производительности.</p>
<h2 id="Архитектура"><a class="header" href="#Архитектура">Архитектура</a></h2>
<p>Для ARM-процессоров, начиная с ARMv7, были определены 3 профиля:</p>
<ul>
<li><strong>A</strong> (Application) - для устройств, требующих высокой производительности;</li>
<li><strong>R</strong> (Real Time) - для приложений, работающих в реальном времени;</li>
<li><strong>M</strong> (Microcontroller) - для микроконтроллеров и встраиваемых устройств;</li>
</ul>
<h2 id="Система-на-кристалле-soc"><a class="header" href="#Система-на-кристалле-soc">Система на кристалле (SoC)</a></h2>
<p>Нас больше интересует не сама архитектура ARM, а <em>системы на кристалле</em> (СнК, SoC), использующие процессоры на этой архитектуре. Такие системы размещены на одной интегральной схеме и выполняют роль сразу нескольких устройств. Из-за небольших размеров таких систем они приобрели популярность в мобильной технике, фотоаппаратах, планшетных компьютерах, электронных книгах, умных часах и т.д., а также в одноплатных компьютерах, например, в Orange Pi, Raspberry Pi, Repka Pi и др.</p>
<p>Как правило, СнК содержат один или несколько микропроцессоров, блок памяти (ПЗУ, ОЗУ и т.д.), регуляторы напряжения и стабилизаторы питания и пр.</p>
<p>СнК потребляют меньше энергии, стоят дешевле и работают надёжнее, чем наборы микросхем с той же функциональностью. Меньшее количество корпусов упрощает монтаж. Однако проектирование и отладка одной большой СнК сложнее и дороже, чем проектирование и отладка серии маленьких микросхем.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Заметки-об-ОС-linux"><a class="header" href="#Заметки-об-ОС-linux">Заметки об ОС Linux</a></h1>
<p>В данном цикле обзорных статей будут рассмотрен ряд вопросов об операционных системах, использующих ядро Linux. Например, будут описаны основные компоненты, из которых состоят эти ОС, их принцип работы и предназначение. В данных статьях по большей мепе интересует <em>что</em> происходит, а не <em>как</em>, т.е. здесь не будет большого числа технических подробностей и мельчайших деталей, а просто краткое обзорное описание основных моментов, касаемых работы описываемых здесь ОС.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Заметки-об-ОС-linux-Часть-1-Обзор"><a class="header" href="#Заметки-об-ОС-linux-Часть-1-Обзор">Заметки об ОС Linux. Часть 1. Обзор</a></h1>
<h2 id="Операционные-системы"><a class="header" href="#Операционные-системы">Операционные системы</a></h2>
<p>Определение, что же такое ОС, весьма объёмно и всеобъемлюще. Но вкратце можно сказать о том, что операционная система — это программное обеспечение, управляющее аппаратным обеспечением компьютера и предоставляющее какие-либо абстракции для остального прикладного ПО, которое запускается на компьютере. Примером таких абстракций можно назвать файл на жёстком диске: компьютер сам по себе не знает, что такое файл, ровно как и на жёстком диске или ином носителе информации у нас содержится последовательность данных, которую мы не можем назвать «файлом» в привычном для нас смысле этого слова. Уже операционная система предоставляет пользователю (и программисту, и программам, запускающимся на этой ОС) такую абстракцию, которая «преобразует» эти данные на жёстком диске в привычные нам файлы и папки.</p>
<p>В широком смысле под операционной системой подразумевается совокупность ядра и работающих поверх него программ и утилит.</p>
<h3 id="Встраиваемые-embedded-системы"><a class="header" href="#Встраиваемые-embedded-системы">Встраиваемые (embedded) системы</a></h3>
<p>LFA основана на руководстве CLFS Embedded, в котором приведены сведения по сборке встраиваемой системы для архитектуры ARM. Поэтому неудивительно, что прямо сейчас описываются именно встраиваемые операционные системы. Встраиваемая ОС (Embedded OS) — такая ОС, которая работает, будучи встроенной непосредственно в девайс, которым она управляет. Т.е. это часть специализированного устройства или платформы, такой как, например устройство бытовой электроники или часть из системы умного дома.</p>
<p>Встроенный компьютер отличается от персонального тем, что встроенная система как правило спроектирована для одной или нескольких конкретных целей, в то время как ПК предназначены для выполнения широкого круга задач. Встроенный компьютер может иметь минимально возможную для выполнения конкретной задачи производительностью, что обеспечивает лёгкую и эффективную компьютерную платформу.</p>
<h3 id="Семейство-unix"><a class="header" href="#Семейство-unix">Семейство Unix</a></h3>
<p>Среди современных операционных систем наиболее распространены два семейства: семейство операционных систем Windows и семейство операционных систем Unix. ОС семейства UNIX нашли применение на суперкомпьютерах, серверах, встраиваемых системах, мобильных устройствах, а с недавнего времени проникают и в сегмент компьютеров для обычных пользователей или офисного плангтона.</p>
<p>Unix — это семейство переносимых, многозадачных и многопользовательских систем. Главная особенность таких систем заключается в том, что это <em>изначально</em> многопользовательские и многозадачные ОС, а также такие ОС созданы таким образом, чтобы их было легко переносить с одной процессорной архитектуры на другую. Модульная структура ОС этого семейства наряду с поддержкой широкого спектра микропроцессоров и других типов оборудования сделала такие ОС достаточно популярными и во встраиваемых решениях.</p>
<p>К семейству Unix относятся многие ОС, например FreeBSD, OpenBSD, NetBSD, macOS X (версии 10.+), minix и другие. Кроме того, к этому семейству, пусть и косвенно (поскольку они не основаны на исходном коде оригинальной UNIX или какого-то из её ответвлений), относятся и ОС, использующие ядро Linux.</p>
<h2 id="ОС-использующие-ядро-linux"><a class="header" href="#ОС-использующие-ядро-linux">ОС, использующие ядро Linux</a></h2>
<p>Linux — это монолитное ядро операционной системы, распространяемое как свободное ПО на условиях лицензии GNU GPL (кроме несвободных компонентов, включая драйверы, использующие прошивки, распространяемые под другими лицензиями). Linux можно назвать «сердцем» любой ОС, описываемой в данном руководстве, в том числе это «сердце» и собранного по этому руководству дистрибутива LFA.</p>
<p>Полноценная ОС не может существовать только из одного ядра, тк ей нужны программы, предназначенные для обеспечения работы и взаимодействия с этой ОС: стандартная библиотека языка С (glibc, musl, bionic, etc.), <a href="additional/os-structure2.html">загрузчик ОС</a> (GRUB, systemd-boot, syslinux, U-Boot), <a href="additional/os-structure3.html">система инициализации</a> (SysVInit, OpenRC, Runit, upstart, systemd) и набор <a href="additional/os-structure4.html">стандартных утилит</a> для работы с компонентами этой ОС (работа с файлами, правами доступа, процессами, пользователями, группами пользователей и т.п., обычно такие утилиты называются «coreutils»: GNU coreutils, uutils coreutils, etc.).</p>
<h3 id="Свободное-ПО"><a class="header" href="#Свободное-ПО">Свободное ПО</a></h3>
<p>Операционная система, использующая ядро Linux, а также все её системные компоненты и большинство её пользовательских приложений — свободные программы. Свободное ПО отличается от несвободного тем, что его можно:</p>
<ul>
<li>запускать на любом количестве компьютеров без всевозможных лицензионных ограничений;</li>
<li>распространять бесплатно или за деньги без каких-либо ограничений;</li>
</ul>
<p>Кроме того, пользователи могут получать исходный код свободного ПО, изучать и модифицировать его, а также распространять модифицированные копии такого ПО.</p>
<h3 id="Разработка-ОС-с-ядром-linux"><a class="header" href="#Разработка-ОС-с-ядром-linux">Разработка ОС с ядром Linux</a></h3>
<p>В отличие от распространённых несвободных ОС вроде Windows или macOS, Linux не имеет географического центра разработки, ровно как нет конкретной фирмы или компании, владеющей Linux, нет и единого координационного центра разработки. Эта ОС — результат работы тысячи программистов по всему миру<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h2 id="Компоненты-ОС-с-ядром-linux"><a class="header" href="#Компоненты-ОС-с-ядром-linux">Компоненты ОС с ядром Linux</a></h2>
<h3 id="Ядро-linux"><a class="header" href="#Ядро-linux">Ядро Linux</a></h3>
<p>Как упоминалось ранее, ядро Linux — это «сердце» операционной системы, которое, к тому же, соответствует стандарту POSIX и распространяется под лицензией GNU GPLv2. Несмотря на <em>свободную</em> лицензию, в составе ядра есть и несвободные компоненты: как правило, это драйверы, использующие несвободные прошивки и иные составляющие.</p>
<p>Linux поддерживает многозадачность, виртуальную память, динамические библиотеки и прочее, что свойственно современным операционным системам. Это монолитное ядро с поддержкой динамически загружаемых модулей. В монолитных ядрах все их компоненты (например, драйверы) как бы встроены в одно большое ядро. Это является противоположностью, например, микроядрам, где очень многие компоненты являются отдельными частями, которые не входят непосредственно в состав ядра (например, это справедливо по отношению к ядру операционной системы Minix).</p>
<p>Из плюсов монолитных ядер можно отметить более прямой доступ к аппаратным средствам, а из минусов: б<em>о</em>льший размер ядра и б<em>о</em>льшее потребление оперативной памяти. Другой минус заключается в том, что когда мы подключаем к компьютеру какое-то новое устройство, драйвер которого существует для монолитного ядра, но в данный момент он не «встроен» в это ядро (т.е. ядро не было скомпилировано с поддержкой этого драйвера), то нам придётся пересобирать ядро, включив там поддержку этого драйвера, что иногда бывает не очень удобным вариантом.</p>
<p>В итоге ядро Linux обзавелось механизмом <em>модулей</em>, которые устанавливаются в отдельный каталог (например, в <code>/lib/modules</code>). Модули мы можем подключать, когда они нам нужны, а когда необходимость их использования сойдёт на нет, их можно выгрузить.</p>
<h3 id="Загрузчик"><a class="header" href="#Загрузчик">Загрузчик</a></h3>
<p>Задача загрузчика — инициализировать и запустить ядро. На компьютерах с архитектурой ARM он может выполнять несколько больше <a href="additional/os-structure2.html">функций</a>, но в основном всё сводится именно к инициализации и запуску ядра ОС.</p>
<h3 id="Система-инициализации-1"><a class="header" href="#Система-инициализации-1">Система инициализации</a></h3>
<p>Ядро запускает систему инициализации (<code>init</code>). В задачи <code>init</code> входит подготовка ОС к дальнейшей работе: инициализация консолей, монтирование виртуальных файловых систем и запуск компонентов системы. Процесс <code>/sbin/init</code> работает как демон и имеет <code>PID</code>=<code>1</code>.</p>
<p>Из основных реализаций системы инициализации в Linux можно отметить systemd, SysVInit, runit и OpenRC. В проекте LFA используется система инициализации из состава BusyBox.</p>
<p><code>init</code> загружается первым процессом (пользовательского режима) после инициализации ядра и отвечает за дальнейшую загрузку системы. Для этого он может либо запускать загрузочные скрипты (написанные, как правило, на BASH или каком-то другом скриптовом языке), либо читает специальные конфигурационные файлы с параметрами загрузки (такое поведение есть, например, у systemd).</p>
<p>Во многих системах Linux (особенно коммерческих) получил наибольшее распространение systemd. Это довольно удобная и функциональная система инициализации, однако некоторые пользователи критикуют её за раздутость, наличие многих ненужных пользователям функций (некоторые компоненты из systemd заменяют <code>chroot</code>, <code>cron</code> и средства для ведения логов системы), а также несколько более высокое потребление ресурсов компьютера по сравнению с другими системами инициализации. Лично для меня существенным недостатком [скорее не самог<em>о</em> systemd, а ряда программ, «прибитых» к нему] является то, что ряд ПО «прибит» к нему и работа такого ПО на системах с другими инитами может быть несколько затруднительной. Примерами такого ПО можно привести рабочие окружения GNOME и KDE. Тем не менее, systemd — довольно продвинутая система инициализации, которая не даром набрала популярность во многих дистрибутивах Linux.</p>
<h3 id="Стандартная-библиотека-языка-С"><a class="header" href="#Стандартная-библиотека-языка-С">Стандартная библиотека языка С</a></h3>
<p>Поскольку системные компоненты ОС Linux написаны преимущественно на языке программирования С, в системе присутствует стандартная библиотека этого языка, с которой динамически линкуются программы системы. Эта стандартная библиотека (<code>libc</code>) содержит системные вызовы и основные функции, которые используются в программе, например функции для работы с файлами, выделения памяти, форматирования вывода в консоль и т.д.</p>
<p>Существует множество различных стандартных библиотек С, самая распространённая из которых — GNU C Library (<code>glibc</code>). Она используется почти во всех известных дистрибутивах GNU/Linux. Однако её часто критикуют за «раздутость» и низкую скорость работы по сравнению с другими библиотеками.</p>
<p>В LFA используется стандартная библиотека С <code>musl</code>. Она была написана с нуля, без переиспользования существующего кода. При её написании уделялось внимание эффективной статической линковке программ. Эта стандартная библиотека получила распространение в минималистичных дистрибутивах Linux, например в Alpine Linux, OpenWRT и других. Применение <code>musl</code> может быть оправдано в минималистичных и встраиваемых системах, поэтому использование её в LFA в целом является хорошей идеей.</p>
<h3 id="Стандартные-утилиты-unix-coreutils"><a class="header" href="#Стандартные-утилиты-unix-coreutils">Стандартные утилиты UNIX (coreutils)</a></h3>
<p>coreutils — это набор базовых утилит операционной системы, которые включают в себя программы для управления файлами (создание, удаление, копирование и перемещение файлов и каталогов, создание ссылок и блочных файлов), правами доступа к файлам (изменение прав доступа к файлу и каталогу, смена владельца и группы файла, etc.), проверки контрольных сумм файлов, работы с текстовой информацией и т.д.</p>
<p>Во многих дистрибутивах Linux в качестве реализации стандартных утилит выступает пакет GNU Coreutils, однако кроме него есть и другие. Например, существует реализация coreutils на языке программирования Rust (<a href="https://uutils.github.io/coreutils/">uutils coreutils</a>). Во встраиваемых системах применяются более простые (а значит и более минималистичные и нетребовательные к ресурсам ПК) реализации, такие как BusyBox и ToyBox, которые объединяют все вышеописанные утилиты в один бинарный файл, имеющий размер от нескольких сотен Кбайт до 2-3 МБайт.</p>
<h3 id="Командная-оболочка-shell"><a class="header" href="#Командная-оболочка-shell">Командная оболочка (shell)</a></h3>
<p>Для того, чтобы пользователь мог взаимодействовать с операционной системой и программами, которые в неё установлены, требуется какая-либо оболочка. Это может быть либо командный интерпретатор типа <code>sh</code>, <code>ash</code>, <code>zsh</code>, <code>csh</code> или <code>bash</code>, либо графическое пользовательское окружение типа GNOME или KDE.</p>
<p>В командной оболочке пользователь может либо давать команды ОС, либо запускать файлы, в которых содержатся списки этих команд (такие файлы называются скриптами).</p>
<p>Командные оболочки позволяют не только запускать какие-либо программы и передавать этим программам нужные аргументы и значения, но также объявлять свои переменные, в которых будут содержаться определённые значения, использовать циклы, конструкции ветвления, а также использовать другие возможности, которые обычно присущи языкам программирования.</p>
<p>В операционных системах семейства Unix пользователь может использовать ветвления, циклы, функции, переменные, работать с арифметическими выражениями, сравнивать числа и строки, а также работать с текстовой информацией.</p>
<p>Эти возможности командных оболочек повсеместно используются во всех системах Unix, в том числе и дистрибутивах Linux. Начиная с процесса загрузки ОС, заканчивая какими-либо пользовательскими задачами. Преимущества Unix-оболочек используются и в этом руководстве при сборке системы.</p>
<p>Во многих дистрибутивах Linux в качестве командной оболочки используется BASH, однако во всяких минималистичных и/или встраиваемых системах можно встретить что-то вроде <code>ash</code> из состава BusyBox — микроверсию оболочки <code>sh</code>, обеспечивающую базовую функциональность shell'а. В других ОС семейства Unix можно встретить <code>csh</code> или <code>tcsh</code> (например, во FreeBSD), либо <code>zsh</code> (в macOS).</p>
<h3 id="Рабочее-окружение-desktop-environment"><a class="header" href="#Рабочее-окружение-desktop-environment">Рабочее окружение (Desktop Environment)</a></h3>
<p>Рабочее окружение — графический интерфейс в ОС семейства Unix, использующий, как правило, окна, панели, иконки и другие элементы GUI. Рабочие окружения состоят из набора различных программ, некоторые из которых разрабатываются в рамках одного проекта, а другие предоставляются сторонними разработчиками.</p>
<img src="additional/pic/gnome.png">
<p><small>Скриншот рабочего окружения GNOME — одного из самых распространённых окружений в Linux. Имеет особую поплярность в коммерческих дистрибутивах Linux, например в Ubuntu или RHEL, но также используется и в свободных ОС, развиваемых сообществом, например в Debian GNU/Linux.</small></p>
<p>Рабочее окружение состоит из следующего ПО:</p>
<ol>
<li>Дисплейный менеджер (запрашивает аутентификационные данные нужного пользователя: его имя, пароль или отпечаток пальца, выбирает, какое рабочее окружение запустить и запускает его);</li>
<li>Оконный менеджер (управляет окнами программ);</li>
<li>Файловый менеджер (выполняет базовые действия с файлами и каталогами: просмотр содержимого директорий, переименование, перемещение, копирование, удаление файлов и директорий, создание ссылок и т.д.);</li>
<li>Панель, на которой расположены апплеты для взаимодействия с окружением (главное меню со списком приложений, часы, область уведомлений, панель управления, на которой можно изменять т.н. «быстрые параметры»: включение/выключение Wi-Fi, Bluetooth, регулировка звука и яркости экрана, кнопки для выключения/перезагрузки компьютера или выхода из текущей сессии пользователя, etc.);</li>
</ol>
<p>В Unix традиционно за обеспечение работы графических пользовательских окружений отвечает X Window System. Это сервер, обеспечивающий базовые функции графической среды: отрисовку и работу окон (их перемещение на экране, изменение размера, etc.), взаимодействие с устройствами ввода (мышь и клавиатура) и т.д. За всё остальное отвечают, как правило, оконные менеджеры, работающие поверх X и определяющие интерфейс и взаимодействие с пользователем.</p>
<p>Оконные менеджеры могут использоваться как в составе рабочего окружения, так и отдельно от него.</p>
<p>В последнее время наблюдается тенденция на отказ от X Window System в пользу протокола Wayland. Он обладает некоторыми достоинствами по сравнению с X.org (по крайней мере это не монолитный и запутанный монстр типа X.org, в котором давным-давно не разбираются даже разработчики, а вполне себе элегантная и простая вещь, вести разработку которой в разы легче и куда проще добавлять новые функции). Кроме того, Wayland не имеет присущих X недостатков и уязвимостей.</p>
<p>Вместо оконных менеджеров для Wayland применяются композитные менеджеры. Среди таких композитных менеджеров для Wayland можно отметить:</p>
<ol>
<li>Weston — эталонная реализация композитного менеджера Wayland;</li>
<li>Sway — аналог тайлинговых оконных менеджеров типа i3-wm для Wayland;</li>
<li>Mutter — из состава рабочего окружения GNOME;</li>
<li>KWin — из состава рабочего окружения KDE;</li>
</ol>
<p>Рассмотрим строение рабочего окружения на примере GNOME Shell:</p>
<ol>
<li>Дисплейный менеджер GDM;</li>
<li>Оконный/композитный менеджер Mutter;</li>
<li>Файловый менеджер Nautilus;</li>
<li>Оболочка GNOME Shell (включает в себя верхнюю панель с переключателем рабочих столов, часы и панель уведомлений, панель быстрых настроек, главное меню, dock со списком запущенных и закреплённых приложений, ряд диалогов и т.д.);</li>
</ol>
<p>Все компоненты рабочих окружений, как правило, тесно интегрированы друг с другом и составляют целую «экосистему» связанного друг с другом ПО.</p>
<p>Во встраиваемых системах как правило нет графического пользовательского окружения, поскольку такие окружения достаточно тяжёлые для слабого встраиваемого оборудования.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>ровно поэтому нет и не может быть никаких «отечественных дистрибутивов Linux» или уж того хуже «отечественных операционных систем» (100% которых — просто дистрибутивы Linux, не более). Вклад российских разработчиков в развитие Linux ровно такой же, как и вклад любого другого разработчика из любого другого государства. Поэтому некорректно называть какой-то дистрибутив российским, французским, китайским и т.д.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Заметки-об-ОС-linux-Часть-2-Процесс-загрузки"><a class="header" href="#Заметки-об-ОС-linux-Часть-2-Процесс-загрузки">Заметки об ОС Linux. Часть 2. Процесс загрузки</a></h1>
<blockquote>
<p>Б<em>о</em>льшая часть сведений здесь взята из статьи <a href="https://habr.com/ru/companies/aladdinrd/articles/338806/">Загрузка ОС на ARM</a> на Хабре.</p>
</blockquote>
<div id="admonition-Внимание" class="admonition admonish-warning">
<div class="admonition-title">
<p>Внимание</p>
<p><a class="admonition-anchor-link" href="additional/os-structure2.html#admonition-Внимание"></a></p>
</div>
<div>
<p>Здесь будут даны сведения о загрузке Linux на ARM. Особенности загрузки других ОС затронуты не будут, поскольку это не тема данного руководства.</p>
</div>
</div>
<h2 id="Загрузчик-ОС"><a class="header" href="#Загрузчик-ОС">Загрузчик ОС</a></h2>
<p>Загрузчик обеспечивает запуск ОС и ряд сервисных функций, например проверку целостности образа ОС перед запуском, обновление ПО, самотестирование и т.д. Очень часто в качестве загрузчика можно встретить U-Boot или иные решения с открытым исходным кодом. Для x86_64 «собратьев» обычно применяются GRUB и systemd-boot.</p>
<p>Таким образом, если очень сильно упростить, то процесс загрузки ОС выглядит следующим образом:</p>
<p><img src="additional/pic/oss2-1.png" alt="" /></p>
<p>Здесь знаком <code>//</code> отмечен момент подачи питания или сброса процессора. Такой простой способ запуска был у некоторых процессоров ARMv7. В более новых версиях процессоров процесс куда сложнее, чем на приведённой схеме.</p>
<p>Схема «Загрузчик» -&gt; «ОС» очень удобна из практических соображений, ведь загрузчик берёт на себя всю низкоуровневую работу:</p>
<ul>
<li>Инициализирует память перед запуском ОС и загружает ядро ОС в память</li>
<li>Инициализирует часть периферии</li>
<li>Иногда реализует хранение двух образов ОС: текущего и резервного или образа для восстановления</li>
</ul>
<p>Например, для запуска Linux на ARM загрузчик должен инициализировать память, хотя бы один терминал, загрузить образ ядра и <a href="additional/dtb.html">Devicetree</a> в память и передать управление ядру. Всё это описано в <a href="https://www.kernel.org/doc/Documentation/arm/Booting"><strong>документации</strong></a> Linux. Код инициализации ядра Linux не будет делать сам то, что должен делать загрузчик.</p>
<p>Рассмотрим работу загрузчика на примере U-Boot:</p>
<ol>
<li>После включения или сброса процессор загружает образ U-Boot в ОЗУ и передаёт управление на первую команду этого образа.</li>
<li>U-Boot инициализирует DDRAM.</li>
<li>U-Boot инициализирует драйверы загрузочного носителя (ЗН), например eMMC, NAND Flash и т.д.</li>
<li>U-Boot читает с ЗН область переменных конфигураций. В конфигурации задан скрипт загрузки, который U-Boot далее исполняет.</li>
<li>U-Boot выводит предложение прервать процесс загрузки и сконфигурировать устройство. Если за 2-3 секунды пользователь этого не сделает, запустится загрузочный скрипт.</li>
<li>Иногда скрипт начинается с поиска подходящего образа ОС для загрузки на всех доступных носителях. В других случаях ЗН задаётся в скрипте жёстко.</li>
<li>Скрипт загружает с ЗН в DDRAM образ ядра (<code>zImage</code>) и файл Devicetree с параметрами ядра.</li>
<li>Дополнительно скрипт может загрузить в память образ <code>initrd</code>.</li>
<li><code>zImage</code> состоит из распаковщика и сжатого образа ядра. Распаковщик развёртывает ядро в памяти.</li>
<li>Начинается загрузка ОС.</li>
</ol>
<h2 id="Предзагрузчик"><a class="header" href="#Предзагрузчик">Предзагрузчик</a></h2>
<p>Однко в реальности почти никогда не бывает, чтобы команды загрузчика выполнялись первыми после включения или сброса процессора, тем более на современных ARM-процессорах.</p>
<p>Любое ядро ARM-процессора при сбросе начинает исполнение с адреса 0, где записан вектор <code>reset</code>. Старые процессоры буквально начинали загружаться с внешней памяти, отображённой по нулевому адресу, и тогда первая команда процессора была первой командой загрузчика. Однако для такой загрузки подходит только параллельная NOR Flash или ROM. Эти типы памяти работают очень просто: при подаче адреса они выдают данные. Характерный пример параллельной NOR Flash — микросхема BIOS в x86/x86_64 компьютерах.</p>
<p>В современных системах используются другие виды памяти, потому что они дешевле, а их объём больше. Это, например, NAND, eMMC, SPI/QSPI Flash. Эти типы памяти уже не работают по типу «подал адрес — читаешь данные», а значит, что для прямого исполнения команд из них не подходят. Даже для простого чтения нужно написать специальный драйвер, поэтому мы имеем проблему «курицы и яйца»: драйвер нужно откуда-то заранее загрузить.</p>
<p>По этой причине в современные ARM-процессоры интегрировано ПЗУ с предзагрузчиком. ПЗУ отображено в процессоре на адрес 0, и именно с этого адреса начинается исполнение команд процессором.</p>
<p>Задачи предзагрузчика:</p>
<ol>
<li>Определение конфигурации подключенных устройств;</li>
<li>Определение загрузочного носителя (ЗН);</li>
<li>Инициализация устройств и ЗН;</li>
<li>Чтение загрузчика с ЗН;</li>
<li>Передача управления загрузчику.</li>
</ol>
<p>Конфигурация предзагрузчика обычно устанавливается одним из двух способов:</p>
<ul>
<li>Схемотехнически — подключением определённых выводов процессора к земле или шине питания;</li>
<li>Записывается в однократно программируемую память процессора на этапе производства.</li>
</ul>
<p>В целом почти всегда есть возможность задать единственный вариант загрузки или основной и несколько альтернативных.</p>
<p>Подобный предзагрузчик устанавливается как в процессорах типа Cortex-A, так и в микроконтроллерах, даже таких маленьких, как Cortex-M0. Вместе с предзагрузчиком процедура запуска ОС выглядит так:</p>
<p><img src="additional/pic/oss2-2.gif" alt="" /></p>
<p>Код предзагрузчика пишется производителем конкретного SoC, а не компанией ARM, является частью SoC как продукта компании-производителя и защищён авторским правом.</p>
<p>Использования предзагрузчика в большинстве сценариев избежать нельзя.</p>
<details id="admonition-Спойлер" class="admonition admonish-note">
<summary class="admonition-title">
<p>Спойлер</p>
<p><a class="admonition-anchor-link" href="additional/os-structure2.html#admonition-Спойлер"></a></p>
</summary>
<div>
<p>У ARMv8-A есть специальная микропрограмма под названием ARM Trusted Firmware (TF-A). Это системное ПО, отвечающее, например, за управление питанием (PSCI). Этот код можно считать, в какой-то степени, BIOS для ARMv8. У более ранних процессоров (например, ARMv7) такого ПО нет.</p>
</div>
</details>
<h2 id="trustzone"><a class="header" href="#trustzone">TrustZone</a></h2>
<p>В процессоры ARM Cortex-A и Cortex-R встраивается технология <a href="https://www.arm.com/products/security-on-arm/trustzone"><strong>TrustZone</strong></a>. Эта технология позволяет на аппаратном уровне выделить два режима исполнения: Secure (Безопасный) и Non-Secure (Гостевой).</p>
<p>Эти процессоры в основном нацелены на рынок смартфонов и планшетных ПК, где TrustZone используется для создания в режиме Secure доверенной «песочницы» для исполнения кода, связанного с криптографией, DRM, хранением пользовательских данных.</p>
<p>В режиме Secure при этом запускается специальная ОС, называемая в общем случае TEE (Trusted Execution Environment, Доверенная Среда Исполнения), а «нормальная» ОС, такая как Linux, iOS и т.д., запускается в режиме Non-Secure. При этом права доступа к некоторым устройствам ограничены для «нормальной» ОС, поэтому её ещё называют <em>гостевой ОС</em>.</p>
<p>Из-за наложенных ограничений гостевая ОС вынуждена время от времени вызывать функции TEE для исполнения некоторых операций. TEE продолжает существовать параллельно с гостевой ОС, и гостевая ОС не может с этим ничего поделать.</p>
<p>Например, гостевая ОС использует функции TEE для:</p>
<ul>
<li>Включения и выключения ядер процессора (в ARMv8-A это происходит через PSCI — часть TF-A);</li>
<li>Хранения ключей, банковских карт и т.п.</li>
<li>Хранения ключей полнодискового шифрования;</li>
<li>Операций с криптографией;</li>
<li>Отображения DRM-контента.</li>
</ul>
<p>Процесс загрузки ОС на ARM (Cortex-A) примерно выглядит так:</p>
<p><img src="additional/pic/oss2-3.png" alt="" /></p>
<p>На схеме пунктиром обозначен путь обращения из ядра ОС в TEE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Заметки-об-ОС-linux-Часть-3-Система-инициализации"><a class="header" href="#Заметки-об-ОС-linux-Часть-3-Система-инициализации">Заметки об ОС Linux. Часть 3. Система инициализации</a></h1>
<p>Как было сказано ранее, <code>/sbin/init</code> - это программа, которая стартует первой в системе. Обычно имеет PID=1. Главная задача системы инициализации (далее - СИ) - довести систему до состояния, пригодного для использования. Для этого СИ может монтировать какие-либо разделы и файловые системы (так например на определённом этапе загрузки СИ выполняет монтирование ряда ФС), а также запускать установленные в системе демоны и иные программы.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Заметки-об-ОС-linux-Часть-4-Стандартные-утилиты-unix"><a class="header" href="#Заметки-об-ОС-linux-Часть-4-Стандартные-утилиты-unix">Заметки об ОС Linux. Часть 4. Стандартные утилиты UNIX</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Управление-пакетами"><a class="header" href="#Управление-пакетами">Управление пакетами</a></h1>
<p>Использование пакетных менеджеров является привычным способом управления пакетами во многих системах, использующих ядро Linux, однако LFA не предполагает использование таких решений, предпочитая использованию готовых инструментов сборку нужного ПО из исходного кода.</p>
<p>Мы не рекомендуем вам использовать уже существующие пакетные менеджеры в собранной системе LFA по ряду причин:</p>
<ul>
<li>Рассмотрение вопросов управления пакетами отвлекает внимание от целей LFA - изучения строения Linux-систем и их процесса проектирования и сборки для ARM-компьютеров.</li>
<li>Типичные пакетные менеджеры предназначены для конкретных дистрибутивов GNU/Linux. Использование таких ПМ в LFA может привести к поломке системы.</li>
<li>Существует множество решений для управления программным обеспечением, каждое из которых имеет свои достоинства и недостатки. Найти идеальное для конкретной задачи решение - задача не авторов LFA, а пользователя.</li>
</ul>
<h2 id="Обновления"><a class="header" href="#Обновления">Обновления</a></h2>
<p>Пакетный менеджер облегчает обновление ПО до новых версий. Как правило, для обновления пакета до новой версии можно использовать инструкции из LFA. Однако есть некоторые моменты, о которых необходимо помнить при обновлении пакетов, особенно в рабочей системе:</p>
<ul>
<li>Если вы <em>уже</em> собрали систему по LFA и с момента сборки прошло некоторое время, то нет нужды устанавливать обновления для пакетов GCC, GMP, MPC, MPFR, Binutils. Их всё равно в системе нет, они используются только для сборки LFA.</li>
<li>Если вам необходимо обновить стандартную библиотеку С (<code>musl</code>), лучше всего будет полностью пересобрать LFA. Несмотря на то, что вы можете просто пересобрать все пакеты в порядке их зависимостей, мы вам не рекомендуем этого делать.</li>
<li>Если пакет, содержащий разделяемую библиотеку (shared library), обновляется и, если имя библиотеки меняется, то все пакеты, динамически связанные с этой библиотекой, должны быть пересобраны для связи с этой библиотекой (обратите внимание, что нет никакой корреляции между версией пакета и именем библиотеки). Например, есть пакет <code>foo-1.0.0</code>, который устанавливает библиотеку <code>libfoo.so.1</code>. Допустим, вы обновляете пакет до более новой версии <code>foo-1.1.7</code>, который устанавливает библиотеку <code>libfoo.so.2</code>. В этом случае все пакеты, динамически связанные с <code>libfoo.so.1</code>, должны быть перекомпилированы для связи с новой <code>libfoo.so.2</code>. <em>Заметьте, что вы не должны удалять предыдущие библиотеки, пока не будут перекомпилированы зависимые пакеты.</em></li>
<li>Если вы обновляете работающую систему, обратите внимание на пакеты, в которых для установки файлов в систему используется команда <code>cp</code>, а не <code>install</code>. Последняя команда обычно безопаснее, если исполняемый файл или библиотека уже загружена в память.</li>
</ul>
<h2 id="Методы-управления-пакетами"><a class="header" href="#Методы-управления-пакетами">Методы управления пакетами</a></h2>
<p>Ниже перечислены некоторые распространённые методы управления ПО. Прежде чем принять решение о выборе пакетного менеджера, рассмотрите указанные ниже методы и определите, лучше ли они тупых и раздутых ПМ.</p>
<h3 id="Держать-всё-в-своей-голове"><a class="header" href="#Держать-всё-в-своей-голове">Держать всё в своей голове</a></h3>
<p>Эта техника применяется в данном руководстве. Мы считаем, что вы, как пользователь, вполне в состоянии запомнить пару десятком установленных в систему пакетов, к тому же, здесь приведены основные сведения о ПО, используемом в LFA: начиная от описания и версии пакета, заканчивая их содержимым (например, в нашем руководстве приведены краткие описания устанавливаемых пакетами программ и библиотек). Данный метод хорош в крайне минималистичных и небольших системах, в которых либо не предполагается управление пакетами как таковое, либо, если и предполагается, то установка или удаление ПО планируется крайне редко.</p>
<h3 id="Установка-в-отдельные-каталоги"><a class="header" href="#Установка-в-отдельные-каталоги">Установка в отдельные каталоги</a></h3>
<p>Эта техника допускает наличия в системе нескольких версий одного и того же пакета. К тому же, она значительно упрощает удаления пакетов, ведь для осуществления этого требуется всего лишь удалить директорию, в которую установлен пакет.</p>
<p>Каждый пакет устанавливается в отдельный каталог. Например, пакет <code>foo-1.0.0</code> будет установлен в <code>/usr/pkg/foo-1.0.0</code>. Из минусов такого подхода можно отметить разрастание переменных окружения <code>PATH</code>, <code>LD_LIBRARY_PATH</code> и др.</p>
<h3 id="Использование-самодостаточных-пакетов"><a class="header" href="#Использование-самодостаточных-пакетов">Использование самодостаточных пакетов</a></h3>
<p>Вы можете использовать и самодостаточные пакеты. Мы не проверяли их работоспособность в LFA, поэтому не можем гарантировать то, что это возможный вариант.</p>
<h3 id="Использование-пакетных-менеджеров"><a class="header" href="#Использование-пакетных-менеджеров">Использование пакетных менеджеров</a></h3>
<p>Несмотря на то, что LFA не использует пакетные менеджеры, поскольку основным её предназначением является именно ручная компиляция программ, вы можете установить какой-либо пакетный менеджер в вашу собранную систему. Обратите внимание, что использование пакетников из распространённых дистрибутивов может сломать вашу LFA, поскольку эти пакетные менеджеры могут не знать о том, какое ПО у вас уже установлено в системе и пытаться переустановить его. Поэтому используйте пакетные менеджеры осторожно.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сборка-ПО-из-исходного-кода"><a class="header" href="#Сборка-ПО-из-исходного-кода">Сборка ПО из исходного кода</a></h1>
<p>Концепция некоторых систем Linux, а иногда и некоторых других ОС семейства Unix неразрывно связана с компиляцией программного обеспечения из исходного кода. Да и многие руководства, связанные с Linux, например LFS, CLFS или LFA также построены вокруг компиляции ПО. Конечно, многие системы Linux снабжены удалёнными хранилищами уже скомпилированных пакетов, но бывают и случаи, когда в репозиториях нет нужного пакета и его приходится собирать из исходников самостоятельно.</p>
<p>Конечно, LFA может дать вам опыт в сборке ПО из исходного кода, однако у пользователей (особенно начинающих) периодически возникали вопросы по поводу компиляции программ; эта страница содержит ответы на основные из вопросов.</p>
<h2 id="Системы-сборки"><a class="header" href="#Системы-сборки">Системы сборки</a></h2>
<p>Современное программное обеспечение достаточно крупное и сложное. Если какую-то простую программу мы сможем скомпилировать всего лишь одной командой, например:</p>
<pre><code class="language-bash"># C
gcc main.c -o main

# C++
g++ main.cpp -o main

# Rust
rustc main.rs
</code></pre>
<p>то более сложные вещи компилируются в несколько команд. Число таких команд может превышать десятки, а то и сотни. Для того, чтобы не набирать их все вручную, можно пойти двумя путями:</p>
<ol>
<li>Написать BASH-скрипт, последовательно выполняющий команды для сборки.</li>
<li>Использовать специальную программу, принимающую на вход определённый файл со сборочными инструкциями, и выполняющая его.</li>
</ol>
<p>Для чего-то простого вполне сойдёт и BASH-скрипт: это просто и быстро, да и интерпретатор BASH (или совместимого с ним языка) присутствует практически во всех ОС семейства Unix. Но что делать, если скрипт выполнил, условно говоря, из 100 команд всего 10, а на 11 произошла ошибка и скрипт прервал свою работу? Мы можем как-то исправить ситуацию и начать сборку заново. Но тогда, когда мы вновь будем исполнять те команды, которые ранее были успешно выполнены, мы просто потеряем время. А если мы хотим производить сборку пакета в несколько потоков, чтобы сократить общее время сборки? BASH-скрипты, насколько я знаю, этого не позволяют. А если нам нужно как-то кастомизировать сборку пакета, скомпилировав только то, что нам необходимо в конкретной ситуации, а всё, что ненужно, пропустить?</p>
<p>Использование простых скриптов для сборки можно оправдать разве что для каких-то простых проектов, для чего-то посложнее и были придуманы системы сборки. Существует множество разных систем сборки, наиболее популярные из которых GNU Make и meson+ninja. В LFA вы встречались только с <code>make</code>, а, например, если заглянете в руководство <a href="https://linuxfromscratch.org/blfs/view/stable"><strong>BLFS</strong></a>, то можете увидеть у некоторых пакетов и другие системы сборки, например CMake или meson+ninja. Последняя особенно полюбилась разработчикам рабочего окружения GNOME и многие из проектов этого окружения уже используют meson+ninja для своей сборки.</p>
<h4 id="Как-определить-какая-система-сборки-используется-у-пакета"><a class="header" href="#Как-определить-какая-система-сборки-используется-у-пакета">Как определить, какая система сборки используется у пакета?</a></h4>
<p>Если вы собираете какой-либо пакет из состава LFA, LFS или BLFS, то об этом можете не беспокоиться: просто используйте инструкции, которые приведены в этих руководствах. В случае, если по поводу сборки пакета не сказано и в документации (например, обычно <em>общие</em> инструкции по сборке приводятся в файле <code>INSTALL</code>, который находится в директории с исходниками программы. Там даны лишь общие сведения по поводу использования основных команд и всё, конкретных сборочных инструкций там как правило нет), то вам придётся определить систему сборки самостоятельно. Например, посмотрите содержимое директории с исходным кодом программы:</p>
<div class="table-wrapper"><table><thead><tr><th>Система сборки</th><th>Типичные для неё файлы</th></tr></thead><tbody>
<tr><td>GNU Make</td><td><code>Makefile</code>, <code>Makefile.in</code>, <code>configure</code>, <code>aclocal.m4</code>, <code>config.guess</code>, <code>config.in</code>, <code>config.sub</code></td></tr>
<tr><td>CMake</td><td><code>CMake.list</code></td></tr>
<tr><td><code>meson</code>+<code>ninja</code></td><td><code>meson.build</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="Кросс-компилятор"><a class="header" href="#Кросс-компилятор">Кросс-компилятор</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fpu-в-arm-процессорах"><a class="header" href="#fpu-в-arm-процессорах">FPU в ARM-процессорах</a></h1>
<h2 id="fpu"><a class="header" href="#fpu">FPU</a></h2>
<p>FPU — это часть процессора для выполнения различных математических операций над вещественными числами. Он поддерживает работу с ними на уровне <em>примитивов</em> — загрузка, выгрузка вещественного числа (в/из специализированных регистров) или математическая операция над ними выполняется одной командой, за счёт чего достигается значительное ускорение таких операций. Типичными операциями является сложение, вычитание, умножение, деление и вычисление квадратного корня. Некоторые FPU также могут выполнять различные трансцендентные функции, такие как экспоненциальные или тригонометрические вычисления, но их точность может быть низкой, поэтому некоторые системы предпочитают вычислять эти функции программно.</p>
<h2 id="vfp"><a class="header" href="#vfp">VFP</a></h2>
<p>Технология VFP (Vector Floating Point) — это сопроцессорное расширение блока <a href="https://en.wikipedia.org/wiki/Floating-point_unit"><strong>FPU (Floating-Point Unit)</strong></a> для архитектуры ARM (в ARMv8 реализовано иначе — сопроцессоры там не определены). Он обеспечивает недорогие вычисления с плавающей запятой одинарной и двойной точности. Архитектура VFP предполагала поддержку выполнения коротких инструкций «векторного режима», но они последовательно обрабатывали каждый элемент вектора и, таким образом, не обеспечивали производительности истинного векторного параллелизма с одной инструкцией и множеством данных (<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data"><strong>SIMD</strong></a>). Поэтому векторный режим был удалён вскоре после появления, а на смену ему пришёл гораздо более мощный Advanced SIMD, также известный как <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)"><strong>Neon</strong></a>.</p>
<p>Некоторые устройства, такие как ARM Cortex-A8, имеют урезанный модуль VFPLite вместо полноценного VFP, и требуют примерно в 10 раз больше тактов на операцию с плавающей запятой. Архитектуры до ARMv8 реализовывали плавающую запяту/SIMD с помощью интерфейса сопроцессора. Другие модули с плавающей запятой и/или SIMD, встречающиеся в ARM процессорах, использующих математический сопроцессор, включают FPA, FPE, iwMMXt, некоторые из которых были реализованы программно, но моги быть реализованы и аппаратно. Они обеспечивают ту же функциональность, что и VFP, но не совместимы с ним по коду. FPA10 также обеспечивает расширенную точность, но реализует корректное округление только в одинарной точности.</p>
<h3 id="vfpv1"><a class="header" href="#vfpv1">VFPv1</a></h3>
<p>Устарел.</p>
<h3 id="vfpv2"><a class="header" href="#vfpv2">VFPv2</a></h3>
<p>Опциональное расширение набора инструкций в архитектурах ARMv5TE, ARMv5TEJ и ARMv6. VFPv2 имеет 16 64-битных регистров FPU.</p>
<h3 id="vfpv3-или-vfpv3-d32"><a class="header" href="#vfpv3-или-vfpv3-d32">VFPv3 или VFPv3-D32</a></h3>
<p>Реализовано в большинстве процессоров Cortex-A8 и A9 ARMv7. Обратно совместим с VFPv2, за исключением того, что не может отлавливать исключения с плавающей точкой. VFPv3 имеет 32 64-битных регистра FPU в качестве стандарта, добавляет инструкции VCVT для преобразования между скалярами, <code>float</code> и <code>double</code>, добавляет немедленный режим в VMOV, чтобы константы могли быть загружены в регистр FPU.</p>
<h3 id="vfpv3-d16"><a class="header" href="#vfpv3-d16">VFPv3-D16</a></h3>
<p>Как и выше, но только с 16 64-битными регистрами FPU. Реализован в процессорах Cortex-R4 и R5, а также в Cortex-A9.</p>
<h3 id="vfpv4-или-vfpv4-d32"><a class="header" href="#vfpv4-или-vfpv4-d32">VFPv4 или VFPv4-D32</a></h3>
<p>Реализован в процессорах Cortex-A12, Cortex-A15. В Cortex-A7 опционально устанавливается VFPv4-D32 в случае использования FPU с Neon.</p>
<h3 id="vfpv4-d16"><a class="header" href="#vfpv4-d16">VFPv4-D16</a></h3>
<p>Реализован в Cortex-A5 и Cortex-A7 если они используют FPU без Neon.</p>
<h3 id="vfpv5-d16-m"><a class="header" href="#vfpv5-d16-m">VFPv5-D16-M</a></h3>
<p>Реализовано в Cortex-M7 при наличии опции ядра с плавающей точкой одинарной и двойной точности.</p>
<p>В Debian Linux и производных, таких как Ubuntu и Linux Mint, armhf (ARM hard float) относится к архитектуре ARMv7, включая дополнительное аппаратное расширение VFP3-D16 с плавающей точкой (и Thumb-2). Программные пакеты и инструменты кросс-компиляторов используют суффиксы armhf и arm/armel для различия.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-tree"><a class="header" href="#device-tree">Device Tree</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Дополнительные-сведения"><a class="header" href="#Дополнительные-сведения">Дополнительные сведения</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Список-ПК-для-которых-собиралась-lfa"><a class="header" href="#Список-ПК-для-которых-собиралась-lfa">Список ПК, для которых собиралась LFA</a></h1>
<h2 id="orange-pi-3-lts"><a class="header" href="#orange-pi-3-lts">Orange Pi 3 LTS</a></h2>
<ul>
<li><strong>Бренд процессора:</strong> Allwinner</li>
<li><strong>Модель процессора:</strong> H6</li>
<li><strong>Архитектура:</strong> Cortex-A53 (AArch64)</li>
<li><strong>Версия LFA:</strong> 0.1 Alpha 1</li>
<li><strong>Статус сборки:</strong> Собирается корректно</li>
<li><strong>Статус функционирования:</strong> Работает корректно</li>
<li><strong>Дата сборки:</strong> 01.01.1970</li>
</ul>
<h3 id="Переменные-сборки"><a class="header" href="#Переменные-сборки">Переменные сборки</a></h3>
<ul>
<li><code><b>$LFA_TGT</b>=&quot;hard&quot;</code></li>
<li><code><b>$LFA_FPU</b>=&quot;vfpv4&quot;</code></li>
<li><code><b>$LFA_HOST</b>=x86_64</code></li>
<li><code><b>$LFA_TGT</b>=&quot;aarch64-linux-musleabihf&quot;</code></li>
<li><code><b>$LFA_ARCH</b>=&quot;armv8-a&quot;</code></li>
</ul>
<h2 id="orange-pi-3b"><a class="header" href="#orange-pi-3b">Orange Pi 3B</a></h2>
<p>...</p>
<h3 id="Переменные-сборки-1"><a class="header" href="#Переменные-сборки-1">Переменные сборки</a></h3>
<p>...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Литература"><a class="header" href="#Литература">Литература</a></h1>
<ul>
<li>Интернет-ресурсы
<ul>
<li><strong><a href="https://clfs.org/view/clfs-embedded/arm/index.html">https://clfs.org/view/clfs-embedded/arm/index.html</a></strong></li>
<li><a href="https://docs.u-boot.org/en/latest/build/gcc.html#building">https://docs.u-boot.org/en/latest/build/gcc.html#building</a></li>
<li><a href="https://en.wikipedia.org/wiki/Floating-point_unit">https://en.wikipedia.org/wiki/Floating-point_unit</a></li>
<li><a href="https://en.wikipedia.org/wiki/ARM_Cortex-A53">https://en.wikipedia.org/wiki/ARM_Cortex-A53</a></li>
<li><a href="https://en.wikipedia.org/wiki/ARM_architecture_family">https://en.wikipedia.org/wiki/ARM_architecture_family</a></li>
<li><a href="https://habr.com/ru/articles/763996/">https://habr.com/ru/articles/763996/</a></li>
<li><a href="https://linux-sunxi.org/U-Boot#Compile_U-Boot">https://linux-sunxi.org/U-Boot#Compile_U-Boot</a></li>
<li><a href="https://linux-sunxi.org/Manual_build_howto">https://linux-sunxi.org/Manual_build_howto</a></li>
<li><a href="https://habr.com/ru/companies/aladdinrd/articles/338806/">https://habr.com/ru/companies/aladdinrd/articles/338806/</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-нового-в-этом-релизе"><a class="header" href="#Что-нового-в-этом-релизе">Что нового в этом релизе</a></h1>
<h2 id="lfa-10"><a class="header" href="#lfa-10">LFA 1.0</a></h2>
<p>Это первая версия руководства LFA, в которой изначально доступно:</p>
<ul>
<li>Сборка кросс-компилятора x86_64 -&gt; ARM</li>
<li>Сборка загрузчика U-Boot для Allwinner SoC</li>
<li>Инструкции по созданию <code>img</code>-образа системы</li>
<li>Более новые версии пакетов по сравнению с оригинальной CLFS</li>
<li>Поставка готового кросс-компилятора <code>or1k-elf-linux</code> для сборки компонентов U-Boot</li>
<li>Полный перевод на русский язык</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Список-изменений"><a class="header" href="#Список-изменений">Список изменений</a></h1>
<!--

## Изменения

## Добавления

## Обновления пакетов

-->
<h2 id="Изменения"><a class="header" href="#Изменения">Изменения</a></h2>
<p>Initial Release</p>
<h2 id="Обновления-пакетов"><a class="header" href="#Обновления-пакетов">Обновления пакетов</a></h2>
<h2 id="01011970"><a class="header" href="#01011970">01.01.1970</a></h2>
<ul>
<li><a href="">Выпущен релиз 1.0</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
